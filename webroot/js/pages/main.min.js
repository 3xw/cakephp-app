/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 775:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "MultiDrag": () => (/* binding */ MultiDragPlugin),
/* harmony export */   "Sortable": () => (/* binding */ Sortable),
/* harmony export */   "Swap": () => (/* binding */ SwapPlugin)
/* harmony export */ });
function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var version = "1.10.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    if (lastChild(sortable)) return;
    var rect = getRect(sortable),
        threshold = sortable[expando].options.emptyInsertThreshold,
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (threshold && insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // assign target only if condition is true


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;
var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)

      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (sortable.options.supportPointer) {
      on(document, 'pointerup', this._deselectMultiDrag);
    } else {
      on(document, 'mouseup', this._deselectMultiDrag);
      on(document, 'touchend', this._deselectMultiDrag);
    }

    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      var sortable = _ref5.sortable,
          cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvt: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
                currentIndex = index(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);


/***/ }),

/***/ 31:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = factory(__webpack_require__(775));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(775)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE_a352__) {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __nested_webpack_require_1282__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1282__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __nested_webpack_require_1282__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __nested_webpack_require_1282__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __nested_webpack_require_1282__.d = function (exports, name, getter) {
        /******/
        if (!__nested_webpack_require_1282__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __nested_webpack_require_1282__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __nested_webpack_require_1282__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __nested_webpack_require_1282__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __nested_webpack_require_1282__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) {
          __nested_webpack_require_1282__.d(ns, key, function (key) {
            return value[key];
          }.bind(null, key));
        }
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __nested_webpack_require_1282__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __nested_webpack_require_1282__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __nested_webpack_require_1282__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __nested_webpack_require_1282__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __nested_webpack_require_1282__(__nested_webpack_require_1282__.s = "fb15");
      /******/
    }(
    /************************************************************************/

    /******/
    {
      /***/
      "01f9":
      /***/
      function f9(module, exports, __nested_webpack_require_6018__) {
        "use strict";

        var LIBRARY = __nested_webpack_require_6018__("2d00");

        var $export = __nested_webpack_require_6018__("5ca1");

        var redefine = __nested_webpack_require_6018__("2aba");

        var hide = __nested_webpack_require_6018__("32e9");

        var Iterators = __nested_webpack_require_6018__("84f2");

        var $iterCreate = __nested_webpack_require_6018__("41a0");

        var setToStringTag = __nested_webpack_require_6018__("7f20");

        var getPrototypeOf = __nested_webpack_require_6018__("38fd");

        var ITERATOR = __nested_webpack_require_6018__("2b4c")('iterator');

        var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

        var FF_ITERATOR = '@@iterator';
        var KEYS = 'keys';
        var VALUES = 'values';

        var returnThis = function returnThis() {
          return this;
        };

        module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);

          var getMethod = function getMethod(kind) {
            if (!BUGGY && kind in proto) return proto[kind];

            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };

              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }

            return function entries() {
              return new Constructor(this, kind);
            };
          };

          var TAG = NAME + ' Iterator';
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
          var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype; // Fix native

          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              // Set @@toStringTag to native iterators
              setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
            }
          } // fix Array#{values, @@iterator}.name in V8 / FF


          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;

            $default = function values() {
              return $native.call(this);
            };
          } // Define iterator


          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
            hide(proto, ITERATOR, $default);
          } // Plug for library


          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;

          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED) for (key in methods) {
              if (!(key in proto)) redefine(proto, key, methods[key]);
            } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
          }

          return methods;
        };
        /***/

      },

      /***/
      "02f4":
      /***/
      function f4(module, exports, __nested_webpack_require_9671__) {
        var toInteger = __nested_webpack_require_9671__("4588");

        var defined = __nested_webpack_require_9671__("be13"); // true  -> String#at
        // false -> String#codePointAt


        module.exports = function (TO_STRING) {
          return function (that, pos) {
            var s = String(defined(that));
            var i = toInteger(pos);
            var l = s.length;
            var a, b;
            if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
            a = s.charCodeAt(i);
            return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
          };
        };
        /***/

      },

      /***/
      "0390":
      /***/
      function _(module, exports, __nested_webpack_require_10523__) {
        "use strict";

        var at = __nested_webpack_require_10523__("02f4")(true); // `AdvanceStringIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-advancestringindex


        module.exports = function (S, index, unicode) {
          return index + (unicode ? at(S, index).length : 1);
        };
        /***/

      },

      /***/
      "0bfb":
      /***/
      function bfb(module, exports, __nested_webpack_require_10960__) {
        "use strict"; // 21.2.5.3 get RegExp.prototype.flags

        var anObject = __nested_webpack_require_10960__("cb7c");

        module.exports = function () {
          var that = anObject(this);
          var result = '';
          if (that.global) result += 'g';
          if (that.ignoreCase) result += 'i';
          if (that.multiline) result += 'm';
          if (that.unicode) result += 'u';
          if (that.sticky) result += 'y';
          return result;
        };
        /***/

      },

      /***/
      "0d58":
      /***/
      function d58(module, exports, __nested_webpack_require_11554__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __nested_webpack_require_11554__("ce10");

        var enumBugKeys = __nested_webpack_require_11554__("e11e");

        module.exports = Object.keys || function keys(O) {
          return $keys(O, enumBugKeys);
        };
        /***/

      },

      /***/
      "1495":
      /***/
      function _(module, exports, __nested_webpack_require_11938__) {
        var dP = __nested_webpack_require_11938__("86cc");

        var anObject = __nested_webpack_require_11938__("cb7c");

        var getKeys = __nested_webpack_require_11938__("0d58");

        module.exports = __nested_webpack_require_11938__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = getKeys(Properties);
          var length = keys.length;
          var i = 0;
          var P;

          while (length > i) {
            dP.f(O, P = keys[i++], Properties[P]);
          }

          return O;
        };
        /***/
      },

      /***/
      "214f":
      /***/
      function f(module, exports, __nested_webpack_require_12599__) {
        "use strict";

        __nested_webpack_require_12599__("b0c5");

        var redefine = __nested_webpack_require_12599__("2aba");

        var hide = __nested_webpack_require_12599__("32e9");

        var fails = __nested_webpack_require_12599__("79e5");

        var defined = __nested_webpack_require_12599__("be13");

        var wks = __nested_webpack_require_12599__("2b4c");

        var regexpExec = __nested_webpack_require_12599__("520a");

        var SPECIES = wks('species');
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          var re = /./;

          re.exec = function () {
            var result = [];
            result.groups = {
              a: '7'
            };
            return result;
          };

          return ''.replace(re, '$<a>') !== '7';
        });

        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
          // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
          var re = /(?:)/;
          var originalExec = re.exec;

          re.exec = function () {
            return originalExec.apply(this, arguments);
          };

          var result = 'ab'.split(re);
          return result.length === 2 && result[0] === 'a' && result[1] === 'b';
        }();

        module.exports = function (KEY, length, exec) {
          var SYMBOL = wks(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function () {
            // String methods call symbol-named RegEp methods
            var O = {};

            O[SYMBOL] = function () {
              return 7;
            };

            return ''[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
            // Symbol-named RegExp methods call .exec
            var execCalled = false;
            var re = /a/;

            re.exec = function () {
              execCalled = true;
              return null;
            };

            if (KEY === 'split') {
              // RegExp[@@split] doesn't call the regex's exec method, but first creates
              // a new one. We need to return the patched regex when creating the new one.
              re.constructor = {};

              re.constructor[SPECIES] = function () {
                return re;
              };
            }

            re[SYMBOL]('');
            return !execCalled;
          }) : undefined;

          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./[SYMBOL];
            var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  // The native String method already delegates to @@method (this
                  // polyfilled function), leasing to infinite recursion.
                  // We avoid it by directly calling the native @@method method.
                  return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, str, arg2)
                  };
                }

                return {
                  done: true,
                  value: nativeMethod.call(str, regexp, arg2)
                };
              }

              return {
                done: false
              };
            });
            var strfn = fns[0];
            var rxfn = fns[1];
            redefine(String.prototype, KEY, strfn);
            hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
            // 21.2.5.11 RegExp.prototype[@@split](string, limit)
            ? function (string, arg) {
              return rxfn.call(string, this, arg);
            } // 21.2.5.6 RegExp.prototype[@@match](string)
            // 21.2.5.9 RegExp.prototype[@@search](string)
            : function (string) {
              return rxfn.call(string, this);
            });
          }
        };
        /***/

      },

      /***/
      "230e":
      /***/
      function e(module, exports, __nested_webpack_require_16939__) {
        var isObject = __nested_webpack_require_16939__("d3f4");

        var document = __nested_webpack_require_16939__("7726").document; // typeof document.createElement is 'object' in old IE


        var is = isObject(document) && isObject(document.createElement);

        module.exports = function (it) {
          return is ? document.createElement(it) : {};
        };
        /***/

      },

      /***/
      "23c6":
      /***/
      function c6(module, exports, __nested_webpack_require_17412__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __nested_webpack_require_17412__("2d95");

        var TAG = __nested_webpack_require_17412__("2b4c")('toStringTag'); // ES3 wrong here


        var ARG = cof(function () {
          return arguments;
        }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

        var tryGet = function tryGet(it, key) {
          try {
            return it[key];
          } catch (e) {
            /* empty */
          }
        };

        module.exports = function (it) {
          var O, T, B;
          return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
          : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
          : ARG ? cof(O) // ES3 arguments fallback
          : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
        };
        /***/

      },

      /***/
      "2621":
      /***/
      function _(module, exports) {
        exports.f = Object.getOwnPropertySymbols;
        /***/
      },

      /***/
      "2aba":
      /***/
      function aba(module, exports, __nested_webpack_require_18579__) {
        var global = __nested_webpack_require_18579__("7726");

        var hide = __nested_webpack_require_18579__("32e9");

        var has = __nested_webpack_require_18579__("69a8");

        var SRC = __nested_webpack_require_18579__("ca5a")('src');

        var $toString = __nested_webpack_require_18579__("fa5b");

        var TO_STRING = 'toString';
        var TPL = ('' + $toString).split(TO_STRING);

        __nested_webpack_require_18579__("8378").inspectSource = function (it) {
          return $toString.call(it);
        };

        (module.exports = function (O, key, val, safe) {
          var isFunction = typeof val == 'function';
          if (isFunction) has(val, 'name') || hide(val, 'name', key);
          if (O[key] === val) return;
          if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

          if (O === global) {
            O[key] = val;
          } else if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else if (O[key]) {
            O[key] = val;
          } else {
            hide(O, key, val);
          } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

        })(Function.prototype, TO_STRING, function toString() {
          return typeof this == 'function' && this[SRC] || $toString.call(this);
        });
        /***/
      },

      /***/
      "2aeb":
      /***/
      function aeb(module, exports, __nested_webpack_require_20021__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __nested_webpack_require_20021__("cb7c");

        var dPs = __nested_webpack_require_20021__("1495");

        var enumBugKeys = __nested_webpack_require_20021__("e11e");

        var IE_PROTO = __nested_webpack_require_20021__("613b")('IE_PROTO');

        var Empty = function Empty() {
          /* empty */
        };

        var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

        var _createDict = function createDict() {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = __nested_webpack_require_20021__("230e")('iframe');

          var i = enumBugKeys.length;
          var lt = '<';
          var gt = '>';
          var iframeDocument;
          iframe.style.display = 'none';

          __nested_webpack_require_20021__("fab2").appendChild(iframe);

          iframe.src = 'javascript:'; // eslint-disable-line no-script-url
          // createDict = iframe.contentWindow.Object;
          // html.removeChild(iframe);

          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
          iframeDocument.close();
          _createDict = iframeDocument.F;

          while (i--) {
            delete _createDict[PROTOTYPE][enumBugKeys[i]];
          }

          return _createDict();
        };

        module.exports = Object.create || function create(O, Properties) {
          var result;

          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

            result[IE_PROTO] = O;
          } else result = _createDict();

          return Properties === undefined ? result : dPs(result, Properties);
        };
        /***/

      },

      /***/
      "2b4c":
      /***/
      function b4c(module, exports, __nested_webpack_require_22040__) {
        var store = __nested_webpack_require_22040__("5537")('wks');

        var uid = __nested_webpack_require_22040__("ca5a");

        var _Symbol = __nested_webpack_require_22040__("7726").Symbol;

        var USE_SYMBOL = typeof _Symbol == 'function';

        var $exports = module.exports = function (name) {
          return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
        };

        $exports.store = store;
        /***/
      },

      /***/
      "2d00":
      /***/
      function d00(module, exports) {
        module.exports = false;
        /***/
      },

      /***/
      "2d95":
      /***/
      function d95(module, exports) {
        var toString = {}.toString;

        module.exports = function (it) {
          return toString.call(it).slice(8, -1);
        };
        /***/

      },

      /***/
      "2fdb":
      /***/
      function fdb(module, exports, __nested_webpack_require_22981__) {
        "use strict"; // 21.1.3.7 String.prototype.includes(searchString, position = 0)

        var $export = __nested_webpack_require_22981__("5ca1");

        var context = __nested_webpack_require_22981__("d2c8");

        var INCLUDES = 'includes';
        $export($export.P + $export.F * __nested_webpack_require_22981__("5147")(INCLUDES), 'String', {
          includes: function includes(searchString
          /* , position = 0 */
          ) {
            return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
          }
        });
        /***/
      },

      /***/
      "32e9":
      /***/
      function e9(module, exports, __nested_webpack_require_23672__) {
        var dP = __nested_webpack_require_23672__("86cc");

        var createDesc = __nested_webpack_require_23672__("4630");

        module.exports = __nested_webpack_require_23672__("9e1e") ? function (object, key, value) {
          return dP.f(object, key, createDesc(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };
        /***/
      },

      /***/
      "38fd":
      /***/
      function fd(module, exports, __nested_webpack_require_24150__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __nested_webpack_require_24150__("69a8");

        var toObject = __nested_webpack_require_24150__("4bf8");

        var IE_PROTO = __nested_webpack_require_24150__("613b")('IE_PROTO');

        var ObjectProto = Object.prototype;

        module.exports = Object.getPrototypeOf || function (O) {
          O = toObject(O);
          if (has(O, IE_PROTO)) return O[IE_PROTO];

          if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
          }

          return O instanceof Object ? ObjectProto : null;
        };
        /***/

      },

      /***/
      "41a0":
      /***/
      function a0(module, exports, __nested_webpack_require_24892__) {
        "use strict";

        var create = __nested_webpack_require_24892__("2aeb");

        var descriptor = __nested_webpack_require_24892__("4630");

        var setToStringTag = __nested_webpack_require_24892__("7f20");

        var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

        __nested_webpack_require_24892__("32e9")(IteratorPrototype, __nested_webpack_require_24892__("2b4c")('iterator'), function () {
          return this;
        });

        module.exports = function (Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, {
            next: descriptor(1, next)
          });
          setToStringTag(Constructor, NAME + ' Iterator');
        };
        /***/

      },

      /***/
      "456d":
      /***/
      function d(module, exports, __nested_webpack_require_25677__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __nested_webpack_require_25677__("4bf8");

        var $keys = __nested_webpack_require_25677__("0d58");

        __nested_webpack_require_25677__("5eda")('keys', function () {
          return function keys(it) {
            return $keys(toObject(it));
          };
        });
        /***/

      },

      /***/
      "4588":
      /***/
      function _(module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;

        module.exports = function (it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
        /***/

      },

      /***/
      "4630":
      /***/
      function _(module, exports) {
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };
        /***/

      },

      /***/
      "4bf8":
      /***/
      function bf8(module, exports, __nested_webpack_require_26743__) {
        // 7.1.13 ToObject(argument)
        var defined = __nested_webpack_require_26743__("be13");

        module.exports = function (it) {
          return Object(defined(it));
        };
        /***/

      },

      /***/
      "5147":
      /***/
      function _(module, exports, __nested_webpack_require_27042__) {
        var MATCH = __nested_webpack_require_27042__("2b4c")('match');

        module.exports = function (KEY) {
          var re = /./;

          try {
            '/./'[KEY](re);
          } catch (e) {
            try {
              re[MATCH] = false;
              return !'/./'[KEY](re);
            } catch (f) {
              /* empty */
            }
          }

          return true;
        };
        /***/

      },

      /***/
      "520a":
      /***/
      function a(module, exports, __nested_webpack_require_27558__) {
        "use strict";

        var regexpFlags = __nested_webpack_require_27558__("0bfb");

        var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.

        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var LAST_INDEX = 'lastIndex';

        var UPDATES_LAST_INDEX_WRONG = function () {
          var re1 = /a/,
              re2 = /b*/g;
          nativeExec.call(re1, 'a');
          nativeExec.call(re2, 'a');
          return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
        }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


        var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

        if (PATCH) {
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;

            if (NPCG_INCLUDED) {
              reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
            }

            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
            match = nativeExec.call(re, str);

            if (UPDATES_LAST_INDEX_WRONG && match) {
              re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
            }

            if (NPCG_INCLUDED && match && match.length > 1) {
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              // eslint-disable-next-line no-loop-func
              nativeReplace.call(match[0], reCopy, function () {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undefined) match[i] = undefined;
                }
              });
            }

            return match;
          };
        }

        module.exports = patchedExec;
        /***/
      },

      /***/
      "52a7":
      /***/
      function a7(module, exports) {
        exports.f = {}.propertyIsEnumerable;
        /***/
      },

      /***/
      "5537":
      /***/
      function _(module, exports, __nested_webpack_require_29911__) {
        var core = __nested_webpack_require_29911__("8378");

        var global = __nested_webpack_require_29911__("7726");

        var SHARED = '__core-js_shared__';
        var store = global[SHARED] || (global[SHARED] = {});
        (module.exports = function (key, value) {
          return store[key] || (store[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: core.version,
          mode: __nested_webpack_require_29911__("2d00") ? 'pure' : 'global',
          copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
        });
        /***/
      },

      /***/
      "5ca1":
      /***/
      function ca1(module, exports, __nested_webpack_require_30570__) {
        var global = __nested_webpack_require_30570__("7726");

        var core = __nested_webpack_require_30570__("8378");

        var hide = __nested_webpack_require_30570__("32e9");

        var redefine = __nested_webpack_require_30570__("2aba");

        var ctx = __nested_webpack_require_30570__("9b43");

        var PROTOTYPE = 'prototype';

        var $export = function $export(type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
          var key, own, out, exp;
          if (IS_GLOBAL) source = name;

          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

            out = (own ? target : source)[key]; // bind timers to global for call from export context

            exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

            if (target) redefine(target, key, out, type & $export.U); // export

            if (exports[key] != out) hide(exports, key, exp);
            if (IS_PROTO && expProto[key] != out) expProto[key] = out;
          }
        };

        global.core = core; // type bitmap

        $export.F = 1; // forced

        $export.G = 2; // global

        $export.S = 4; // static

        $export.P = 8; // proto

        $export.B = 16; // bind

        $export.W = 32; // wrap

        $export.U = 64; // safe

        $export.R = 128; // real proto method for `library`

        module.exports = $export;
        /***/
      },

      /***/
      "5eda":
      /***/
      function eda(module, exports, __nested_webpack_require_32628__) {
        // most Object methods by ES6 should accept primitives
        var $export = __nested_webpack_require_32628__("5ca1");

        var core = __nested_webpack_require_32628__("8378");

        var fails = __nested_webpack_require_32628__("79e5");

        module.exports = function (KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export($export.S + $export.F * fails(function () {
            fn(1);
          }), 'Object', exp);
        };
        /***/

      },

      /***/
      "5f1b":
      /***/
      function f1b(module, exports, __nested_webpack_require_33249__) {
        "use strict";

        var classof = __nested_webpack_require_33249__("23c6");

        var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
        // https://tc39.github.io/ecma262/#sec-regexpexec

        module.exports = function (R, S) {
          var exec = R.exec;

          if (typeof exec === 'function') {
            var result = exec.call(R, S);

            if (_typeof(result) !== 'object') {
              throw new TypeError('RegExp exec method returned something other than an Object or null');
            }

            return result;
          }

          if (classof(R) !== 'RegExp') {
            throw new TypeError('RegExp#exec called on incompatible receiver');
          }

          return builtinExec.call(R, S);
        };
        /***/

      },

      /***/
      "613b":
      /***/
      function b(module, exports, __nested_webpack_require_34141__) {
        var shared = __nested_webpack_require_34141__("5537")('keys');

        var uid = __nested_webpack_require_34141__("ca5a");

        module.exports = function (key) {
          return shared[key] || (shared[key] = uid(key));
        };
        /***/

      },

      /***/
      "626a":
      /***/
      function a(module, exports, __nested_webpack_require_34479__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __nested_webpack_require_34479__("2d95"); // eslint-disable-next-line no-prototype-builtins


        module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
          return cof(it) == 'String' ? it.split('') : Object(it);
        };
        /***/
      },

      /***/
      "6762":
      /***/
      function _(module, exports, __nested_webpack_require_34939__) {
        "use strict"; // https://github.com/tc39/Array.prototype.includes

        var $export = __nested_webpack_require_34939__("5ca1");

        var $includes = __nested_webpack_require_34939__("c366")(true);

        $export($export.P, 'Array', {
          includes: function includes(el
          /* , fromIndex = 0 */
          ) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
          }
        });

        __nested_webpack_require_34939__("9c6c")('includes');
        /***/

      },

      /***/
      "6821":
      /***/
      function _(module, exports, __nested_webpack_require_35534__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __nested_webpack_require_35534__("626a");

        var defined = __nested_webpack_require_35534__("be13");

        module.exports = function (it) {
          return IObject(defined(it));
        };
        /***/

      },

      /***/
      "69a8":
      /***/
      function a8(module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;

        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };
        /***/

      },

      /***/
      "6a99":
      /***/
      function a99(module, exports, __nested_webpack_require_36188__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __nested_webpack_require_36188__("d3f4"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string


        module.exports = function (it, S) {
          if (!isObject(it)) return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
          if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          throw TypeError("Can't convert object to primitive value");
        };
        /***/

      },

      /***/
      "7333":
      /***/
      function _(module, exports, __nested_webpack_require_37057__) {
        "use strict"; // 19.1.2.1 Object.assign(target, source, ...)

        var getKeys = __nested_webpack_require_37057__("0d58");

        var gOPS = __nested_webpack_require_37057__("2621");

        var pIE = __nested_webpack_require_37057__("52a7");

        var toObject = __nested_webpack_require_37057__("4bf8");

        var IObject = __nested_webpack_require_37057__("626a");

        var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

        module.exports = !$assign || __nested_webpack_require_37057__("79e5")(function () {
          var A = {};
          var B = {}; // eslint-disable-next-line no-undef

          var S = Symbol();
          var K = 'abcdefghijklmnopqrst';
          A[S] = 7;
          K.split('').forEach(function (k) {
            B[k] = k;
          });
          return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
        }) ? function assign(target, source) {
          // eslint-disable-line no-unused-vars
          var T = toObject(target);
          var aLen = arguments.length;
          var index = 1;
          var getSymbols = gOPS.f;
          var isEnum = pIE.f;

          while (aLen > index) {
            var S = IObject(arguments[index++]);
            var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
            var length = keys.length;
            var j = 0;
            var key;

            while (length > j) {
              if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
            }
          }

          return T;
        } : $assign;
        /***/
      },

      /***/
      "7726":
      /***/
      function _(module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
        : Function('return this')();
        if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

        /***/
      },

      /***/
      "77f1":
      /***/
      function f1(module, exports, __nested_webpack_require_39211__) {
        var toInteger = __nested_webpack_require_39211__("4588");

        var max = Math.max;
        var min = Math.min;

        module.exports = function (index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };
        /***/

      },

      /***/
      "79e5":
      /***/
      function e5(module, exports) {
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
        /***/

      },

      /***/
      "7f20":
      /***/
      function f20(module, exports, __nested_webpack_require_39877__) {
        var def = __nested_webpack_require_39877__("86cc").f;

        var has = __nested_webpack_require_39877__("69a8");

        var TAG = __nested_webpack_require_39877__("2b4c")('toStringTag');

        module.exports = function (it, tag, stat) {
          if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
            configurable: true,
            value: tag
          });
        };
        /***/

      },

      /***/
      "8378":
      /***/
      function _(module, exports) {
        var core = module.exports = {
          version: '2.6.5'
        };
        if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

        /***/
      },

      /***/
      "84f2":
      /***/
      function f2(module, exports) {
        module.exports = {};
        /***/
      },

      /***/
      "86cc":
      /***/
      function cc(module, exports, __nested_webpack_require_40751__) {
        var anObject = __nested_webpack_require_40751__("cb7c");

        var IE8_DOM_DEFINE = __nested_webpack_require_40751__("c69a");

        var toPrimitive = __nested_webpack_require_40751__("6a99");

        var dP = Object.defineProperty;
        exports.f = __nested_webpack_require_40751__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE) try {
            return dP(O, P, Attributes);
          } catch (e) {
            /* empty */
          }
          if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
          if ('value' in Attributes) O[P] = Attributes.value;
          return O;
        };
        /***/
      },

      /***/
      "9b43":
      /***/
      function b43(module, exports, __nested_webpack_require_41622__) {
        // optional / simple context binding
        var aFunction = __nested_webpack_require_41622__("d8e8");

        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;

          switch (length) {
            case 1:
              return function (a) {
                return fn.call(that, a);
              };

            case 2:
              return function (a, b) {
                return fn.call(that, a, b);
              };

            case 3:
              return function (a, b, c) {
                return fn.call(that, a, b, c);
              };
          }

          return function ()
          /* ...args */
          {
            return fn.apply(that, arguments);
          };
        };
        /***/

      },

      /***/
      "9c6c":
      /***/
      function c6c(module, exports, __nested_webpack_require_42507__) {
        // 22.1.3.31 Array.prototype[@@unscopables]
        var UNSCOPABLES = __nested_webpack_require_42507__("2b4c")('unscopables');

        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == undefined) __nested_webpack_require_42507__("32e9")(ArrayProto, UNSCOPABLES, {});

        module.exports = function (key) {
          ArrayProto[UNSCOPABLES][key] = true;
        };
        /***/

      },

      /***/
      "9def":
      /***/
      function def(module, exports, __nested_webpack_require_43003__) {
        // 7.1.15 ToLength
        var toInteger = __nested_webpack_require_43003__("4588");

        var min = Math.min;

        module.exports = function (it) {
          return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };
        /***/

      },

      /***/
      "9e1e":
      /***/
      function e1e(module, exports, __nested_webpack_require_43393__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__nested_webpack_require_43393__("79e5")(function () {
          return Object.defineProperty({}, 'a', {
            get: function get() {
              return 7;
            }
          }).a != 7;
        });
        /***/
      },

      /***/
      "a352":
      /***/
      function a352(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
        /***/
      },

      /***/
      "a481":
      /***/
      function a481(module, exports, __nested_webpack_require_43950__) {
        "use strict";

        var anObject = __nested_webpack_require_43950__("cb7c");

        var toObject = __nested_webpack_require_43950__("4bf8");

        var toLength = __nested_webpack_require_43950__("9def");

        var toInteger = __nested_webpack_require_43950__("4588");

        var advanceStringIndex = __nested_webpack_require_43950__("0390");

        var regExpExec = __nested_webpack_require_43950__("5f1b");

        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

        var maybeToString = function maybeToString(it) {
          return it === undefined ? it : String(it);
        }; // @@replace logic


        __nested_webpack_require_43950__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
          return [// `String.prototype.replace` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O = defined(this);
            var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
            return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
          }, // `RegExp.prototype[@@replace]` method
          // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
          function (regexp, replaceValue) {
            var res = maybeCallNative($replace, regexp, this, replaceValue);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var functionalReplace = typeof replaceValue === 'function';
            if (!functionalReplace) replaceValue = String(replaceValue);
            var global = rx.global;

            if (global) {
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }

            var results = [];

            while (true) {
              var result = regExpExec(rx, S);
              if (result === null) break;
              results.push(result);
              if (!global) break;
              var matchStr = String(result[0]);
              if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }

            var accumulatedResult = '';
            var nextSourcePosition = 0;

            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = String(result[0]);
              var position = max(min(toInteger(result.index), S.length), 0);
              var captures = []; // NOTE: This is equivalent to
              //   captures = result.slice(1).map(maybeToString)
              // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
              // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
              // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

              for (var j = 1; j < result.length; j++) {
                captures.push(maybeToString(result[j]));
              }

              var namedCaptures = result.groups;

              if (functionalReplace) {
                var replacerArgs = [matched].concat(captures, position, S);
                if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                var replacement = String(replaceValue.apply(undefined, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }

              if (position >= nextSourcePosition) {
                accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }

            return accumulatedResult + S.slice(nextSourcePosition);
          }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

          function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

            if (namedCaptures !== undefined) {
              namedCaptures = toObject(namedCaptures);
              symbols = SUBSTITUTION_SYMBOLS;
            }

            return $replace.call(replacement, symbols, function (match, ch) {
              var capture;

              switch (ch.charAt(0)) {
                case '$':
                  return '$';

                case '&':
                  return matched;

                case '`':
                  return str.slice(0, position);

                case "'":
                  return str.slice(tailPos);

                case '<':
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;

                default:
                  // \d\d?
                  var n = +ch;
                  if (n === 0) return match;

                  if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match;
                  }

                  capture = captures[n - 1];
              }

              return capture === undefined ? '' : capture;
            });
          }
        });
        /***/

      },

      /***/
      "aae3":
      /***/
      function aae3(module, exports, __nested_webpack_require_49588__) {
        // 7.2.8 IsRegExp(argument)
        var isObject = __nested_webpack_require_49588__("d3f4");

        var cof = __nested_webpack_require_49588__("2d95");

        var MATCH = __nested_webpack_require_49588__("2b4c")('match');

        module.exports = function (it) {
          var isRegExp;
          return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
        };
        /***/

      },

      /***/
      "ac6a":
      /***/
      function ac6a(module, exports, __nested_webpack_require_50091__) {
        var $iterators = __nested_webpack_require_50091__("cadf");

        var getKeys = __nested_webpack_require_50091__("0d58");

        var redefine = __nested_webpack_require_50091__("2aba");

        var global = __nested_webpack_require_50091__("7726");

        var hide = __nested_webpack_require_50091__("32e9");

        var Iterators = __nested_webpack_require_50091__("84f2");

        var wks = __nested_webpack_require_50091__("2b4c");

        var ITERATOR = wks('iterator');
        var TO_STRING_TAG = wks('toStringTag');
        var ArrayValues = Iterators.Array;
        var DOMIterables = {
          CSSRuleList: true,
          // TODO: Not spec compliant, should be false.
          CSSStyleDeclaration: false,
          CSSValueList: false,
          ClientRectList: false,
          DOMRectList: false,
          DOMStringList: false,
          DOMTokenList: true,
          DataTransferItemList: false,
          FileList: false,
          HTMLAllCollection: false,
          HTMLCollection: false,
          HTMLFormElement: false,
          HTMLSelectElement: false,
          MediaList: true,
          // TODO: Not spec compliant, should be false.
          MimeTypeArray: false,
          NamedNodeMap: false,
          NodeList: true,
          PaintRequestList: false,
          Plugin: false,
          PluginArray: false,
          SVGLengthList: false,
          SVGNumberList: false,
          SVGPathSegList: false,
          SVGPointList: false,
          SVGStringList: false,
          SVGTransformList: false,
          SourceBufferList: false,
          StyleSheetList: true,
          // TODO: Not spec compliant, should be false.
          TextTrackCueList: false,
          TextTrackList: false,
          TouchList: false
        };

        for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
          var NAME = collections[i];
          var explicit = DOMIterables[NAME];
          var Collection = global[NAME];
          var proto = Collection && Collection.prototype;
          var key;

          if (proto) {
            if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
            if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
            Iterators[NAME] = ArrayValues;
            if (explicit) for (key in $iterators) {
              if (!proto[key]) redefine(proto, key, $iterators[key], true);
            }
          }
        }
        /***/

      },

      /***/
      "b0c5":
      /***/
      function b0c5(module, exports, __nested_webpack_require_52572__) {
        "use strict";

        var regexpExec = __nested_webpack_require_52572__("520a");

        __nested_webpack_require_52572__("5ca1")({
          target: 'RegExp',
          proto: true,
          forced: regexpExec !== /./.exec
        }, {
          exec: regexpExec
        });
        /***/

      },

      /***/
      "be13":
      /***/
      function be13(module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function (it) {
          if (it == undefined) throw TypeError("Can't call method on  " + it);
          return it;
        };
        /***/

      },

      /***/
      "c366":
      /***/
      function c366(module, exports, __nested_webpack_require_53260__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __nested_webpack_require_53260__("6821");

        var toLength = __nested_webpack_require_53260__("9def");

        var toAbsoluteIndex = __nested_webpack_require_53260__("77f1");

        module.exports = function (IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value; // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare

            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++]; // eslint-disable-next-line no-self-compare

              if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) {
              if (IS_INCLUDES || index in O) {
                if (O[index] === el) return IS_INCLUDES || index || 0;
              }
            }
            return !IS_INCLUDES && -1;
          };
        };
        /***/

      },

      /***/
      "c649":
      /***/
      function c649(module, __webpack_exports__, __nested_webpack_require_54520__) {
        "use strict";
        /* WEBPACK VAR INJECTION */

        (function (global) {
          /* harmony export (binding) */
          __nested_webpack_require_54520__.d(__webpack_exports__, "c", function () {
            return insertNodeAt;
          });
          /* harmony export (binding) */


          __nested_webpack_require_54520__.d(__webpack_exports__, "a", function () {
            return camelize;
          });
          /* harmony export (binding) */


          __nested_webpack_require_54520__.d(__webpack_exports__, "b", function () {
            return console;
          });
          /* harmony export (binding) */


          __nested_webpack_require_54520__.d(__webpack_exports__, "d", function () {
            return removeNode;
          });
          /* harmony import */


          var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_54520__("a481");
          /* harmony import */


          var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_54520__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);

          function getConsole() {
            if (typeof window !== "undefined") {
              return window.console;
            }

            return global.console;
          }

          var console = getConsole();

          function cached(fn) {
            var cache = Object.create(null);
            return function cachedFn(str) {
              var hit = cache[str];
              return hit || (cache[str] = fn(str));
            };
          }

          var regex = /-(\w)/g;
          var camelize = cached(function (str) {
            return str.replace(regex, function (_, c) {
              return c ? c.toUpperCase() : "";
            });
          });

          function removeNode(node) {
            if (node.parentElement !== null) {
              node.parentElement.removeChild(node);
            }
          }

          function insertNodeAt(fatherNode, node, position) {
            var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
            fatherNode.insertBefore(node, refNode);
          }
          /* WEBPACK VAR INJECTION */

        }).call(this, __nested_webpack_require_54520__("c8ba"));
        /***/
      },

      /***/
      "c69a":
      /***/
      function c69a(module, exports, __nested_webpack_require_56900__) {
        module.exports = !__nested_webpack_require_56900__("9e1e") && !__nested_webpack_require_56900__("79e5")(function () {
          return Object.defineProperty(__nested_webpack_require_56900__("230e")('div'), 'a', {
            get: function get() {
              return 7;
            }
          }).a != 7;
        });
        /***/
      },

      /***/
      "c8ba":
      /***/
      function c8ba(module, exports) {
        var g; // This works in non-strict mode

        g = function () {
          return this;
        }();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}


        module.exports = g;
        /***/
      },

      /***/
      "ca5a":
      /***/
      function ca5a(module, exports) {
        var id = 0;
        var px = Math.random();

        module.exports = function (key) {
          return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
        };
        /***/

      },

      /***/
      "cadf":
      /***/
      function cadf(module, exports, __nested_webpack_require_58353__) {
        "use strict";

        var addToUnscopables = __nested_webpack_require_58353__("9c6c");

        var step = __nested_webpack_require_58353__("d53b");

        var Iterators = __nested_webpack_require_58353__("84f2");

        var toIObject = __nested_webpack_require_58353__("6821"); // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()


        module.exports = __nested_webpack_require_58353__("01f9")(Array, 'Array', function (iterated, kind) {
          this._t = toIObject(iterated); // target

          this._i = 0; // next index

          this._k = kind; // kind
          // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var kind = this._k;
          var index = this._i++;

          if (!O || index >= O.length) {
            this._t = undefined;
            return step(1);
          }

          if (kind == 'keys') return step(0, index);
          if (kind == 'values') return step(0, O[index]);
          return step(0, [index, O[index]]);
        }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

        Iterators.Arguments = Iterators.Array;
        addToUnscopables('keys');
        addToUnscopables('values');
        addToUnscopables('entries');
        /***/
      },

      /***/
      "cb7c":
      /***/
      function cb7c(module, exports, __nested_webpack_require_59808__) {
        var isObject = __nested_webpack_require_59808__("d3f4");

        module.exports = function (it) {
          if (!isObject(it)) throw TypeError(it + ' is not an object!');
          return it;
        };
        /***/

      },

      /***/
      "ce10":
      /***/
      function ce10(module, exports, __nested_webpack_require_60130__) {
        var has = __nested_webpack_require_60130__("69a8");

        var toIObject = __nested_webpack_require_60130__("6821");

        var arrayIndexOf = __nested_webpack_require_60130__("c366")(false);

        var IE_PROTO = __nested_webpack_require_60130__("613b")('IE_PROTO');

        module.exports = function (object, names) {
          var O = toIObject(object);
          var i = 0;
          var result = [];
          var key;

          for (key in O) {
            if (key != IE_PROTO) has(O, key) && result.push(key);
          } // Don't enum bug & hidden keys


          while (names.length > i) {
            if (has(O, key = names[i++])) {
              ~arrayIndexOf(result, key) || result.push(key);
            }
          }

          return result;
        };
        /***/

      },

      /***/
      "d2c8":
      /***/
      function d2c8(module, exports, __nested_webpack_require_60986__) {
        // helper for String#{startsWith, endsWith, includes}
        var isRegExp = __nested_webpack_require_60986__("aae3");

        var defined = __nested_webpack_require_60986__("be13");

        module.exports = function (that, searchString, NAME) {
          if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
          return String(defined(that));
        };
        /***/

      },

      /***/
      "d3f4":
      /***/
      function d3f4(module, exports) {
        module.exports = function (it) {
          return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
        };
        /***/

      },

      /***/
      "d53b":
      /***/
      function d53b(module, exports) {
        module.exports = function (done, value) {
          return {
            value: value,
            done: !!done
          };
        };
        /***/

      },

      /***/
      "d8e8":
      /***/
      function d8e8(module, exports) {
        module.exports = function (it) {
          if (typeof it != 'function') throw TypeError(it + ' is not a function!');
          return it;
        };
        /***/

      },

      /***/
      "e11e":
      /***/
      function e11e(module, exports) {
        // IE 8- don't enum bug keys
        module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
        /***/
      },

      /***/
      "f559":
      /***/
      function f559(module, exports, __nested_webpack_require_62504__) {
        "use strict"; // 21.1.3.18 String.prototype.startsWith(searchString [, position ])

        var $export = __nested_webpack_require_62504__("5ca1");

        var toLength = __nested_webpack_require_62504__("9def");

        var context = __nested_webpack_require_62504__("d2c8");

        var STARTS_WITH = 'startsWith';
        var $startsWith = ''[STARTS_WITH];
        $export($export.P + $export.F * __nested_webpack_require_62504__("5147")(STARTS_WITH), 'String', {
          startsWith: function startsWith(searchString
          /* , position = 0 */
          ) {
            var that = context(this, searchString, STARTS_WITH);
            var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
            var search = String(searchString);
            return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
          }
        });
        /***/
      },

      /***/
      "f6fd":
      /***/
      function f6fd(module, exports) {
        // document.currentScript polyfill by Adam Miller
        // MIT license
        (function (document) {
          var currentScript = "currentScript",
              scripts = document.getElementsByTagName('script'); // Live NodeList collection
          // If browser needs currentScript polyfill, add get currentScript() to the document object

          if (!(currentScript in document)) {
            Object.defineProperty(document, currentScript, {
              get: function get() {
                // IE 6-10 supports script readyState
                // IE 10+ support stack trace
                try {
                  throw new Error();
                } catch (err) {
                  // Find the second match for the "at" string to get file src url from stack.
                  // Specifically works with the format of stack traces in IE.
                  var i,
                      res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1]; // For all scripts on the page, if src matches or if ready state is interactive, return the script tag

                  for (i in scripts) {
                    if (scripts[i].src == res || scripts[i].readyState == "interactive") {
                      return scripts[i];
                    }
                  } // If no match, return null


                  return null;
                }
              }
            });
          }
        })(document);
        /***/

      },

      /***/
      "f751":
      /***/
      function f751(module, exports, __nested_webpack_require_65063__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __nested_webpack_require_65063__("5ca1");

        $export($export.S + $export.F, 'Object', {
          assign: __nested_webpack_require_65063__("7333")
        });
        /***/
      },

      /***/
      "fa5b":
      /***/
      function fa5b(module, exports, __nested_webpack_require_65396__) {
        module.exports = __nested_webpack_require_65396__("5537")('native-function-to-string', Function.toString);
        /***/
      },

      /***/
      "fab2":
      /***/
      function fab2(module, exports, __nested_webpack_require_65620__) {
        var document = __nested_webpack_require_65620__("7726").document;

        module.exports = document && document.documentElement;
        /***/
      },

      /***/
      "fb15":
      /***/
      function fb15(module, __webpack_exports__, __nested_webpack_require_65879__) {
        "use strict"; // ESM COMPAT FLAG

        __nested_webpack_require_65879__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
        // This file is imported into lib/wc client bundles.


        if (typeof window !== 'undefined') {
          if (true) {
            __nested_webpack_require_65879__("f6fd");
          }

          var setPublicPath_i;

          if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
            __nested_webpack_require_65879__.p = setPublicPath_i[1]; // eslint-disable-line
          }
        } // Indicate to webpack that this file can be concatenated

        /* harmony default export */


        var setPublicPath = null; // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js

        var es6_object_assign = __nested_webpack_require_65879__("f751"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js


        var es6_string_starts_with = __nested_webpack_require_65879__("f559"); // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js


        var web_dom_iterable = __nested_webpack_require_65879__("ac6a"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js


        var es6_array_iterator = __nested_webpack_require_65879__("cadf"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js


        var es6_object_keys = __nested_webpack_require_65879__("456d"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js


        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js


        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js


        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js


        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js


        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js


        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        } // EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js


        var es7_array_includes = __nested_webpack_require_65879__("6762"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js


        var es6_string_includes = __nested_webpack_require_65879__("2fdb"); // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js


        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js


        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js


        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        } // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js


        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        } // EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}


        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __nested_webpack_require_65879__("a352");

        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__nested_webpack_require_65879__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_); // EXTERNAL MODULE: ./src/util/helper.js


        var helper = __nested_webpack_require_65879__("c649"); // CONCATENATED MODULE: ./src/vuedraggable.js


        function buildAttribute(object, propName, value) {
          if (value === undefined) {
            return object;
          }

          object = object || {};
          object[propName] = value;
          return object;
        }

        function computeVmIndex(vnodes, element) {
          return vnodes.map(function (elt) {
            return elt.elm;
          }).indexOf(element);
        }

        function _computeIndexes(slots, children, isTransition, footerOffset) {
          if (!slots) {
            return [];
          }

          var elmFromNodes = slots.map(function (elt) {
            return elt.elm;
          });
          var footerIndex = children.length - footerOffset;

          var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
            return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
          });

          return isTransition ? rawIndexes.filter(function (ind) {
            return ind !== -1;
          }) : rawIndexes;
        }

        function emit(evtName, evtData) {
          var _this = this;

          this.$nextTick(function () {
            return _this.$emit(evtName.toLowerCase(), evtData);
          });
        }

        function delegateAndEmit(evtName) {
          var _this2 = this;

          return function (evtData) {
            if (_this2.realList !== null) {
              _this2["onDrag" + evtName](evtData);
            }

            emit.call(_this2, evtName, evtData);
          };
        }

        function isTransitionName(name) {
          return ["transition-group", "TransitionGroup"].includes(name);
        }

        function vuedraggable_isTransition(slots) {
          if (!slots || slots.length !== 1) {
            return false;
          }

          var _slots = _slicedToArray(slots, 1),
              componentOptions = _slots[0].componentOptions;

          if (!componentOptions) {
            return false;
          }

          return isTransitionName(componentOptions.tag);
        }

        function getSlot(slot, scopedSlot, key) {
          return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);
        }

        function computeChildrenAndOffsets(children, slot, scopedSlot) {
          var headerOffset = 0;
          var footerOffset = 0;
          var header = getSlot(slot, scopedSlot, "header");

          if (header) {
            headerOffset = header.length;
            children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
          }

          var footer = getSlot(slot, scopedSlot, "footer");

          if (footer) {
            footerOffset = footer.length;
            children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
          }

          return {
            children: children,
            headerOffset: headerOffset,
            footerOffset: footerOffset
          };
        }

        function getComponentAttributes($attrs, componentData) {
          var attributes = null;

          var update = function update(name, value) {
            attributes = buildAttribute(attributes, name, value);
          };

          var attrs = Object.keys($attrs).filter(function (key) {
            return key === "id" || key.startsWith("data-");
          }).reduce(function (res, key) {
            res[key] = $attrs[key];
            return res;
          }, {});
          update("attrs", attrs);

          if (!componentData) {
            return attributes;
          }

          var on = componentData.on,
              props = componentData.props,
              componentDataAttrs = componentData.attrs;
          update("on", on);
          update("props", props);
          Object.assign(attributes.attrs, componentDataAttrs);
          return attributes;
        }

        var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
        var eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
        var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
          return "on" + evt;
        });
        var draggingElement = null;
        var props = {
          options: Object,
          list: {
            type: Array,
            required: false,
            "default": null
          },
          value: {
            type: Array,
            required: false,
            "default": null
          },
          noTransitionOnDrag: {
            type: Boolean,
            "default": false
          },
          clone: {
            type: Function,
            "default": function _default(original) {
              return original;
            }
          },
          element: {
            type: String,
            "default": "div"
          },
          tag: {
            type: String,
            "default": null
          },
          move: {
            type: Function,
            "default": null
          },
          componentData: {
            type: Object,
            required: false,
            "default": null
          }
        };
        var draggableComponent = {
          name: "draggable",
          inheritAttrs: false,
          props: props,
          data: function data() {
            return {
              transitionMode: false,
              noneFunctionalComponentMode: false
            };
          },
          render: function render(h) {
            var slots = this.$slots["default"];
            this.transitionMode = vuedraggable_isTransition(slots);

            var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),
                children = _computeChildrenAndOf.children,
                headerOffset = _computeChildrenAndOf.headerOffset,
                footerOffset = _computeChildrenAndOf.footerOffset;

            this.headerOffset = headerOffset;
            this.footerOffset = footerOffset;
            var attributes = getComponentAttributes(this.$attrs, this.componentData);
            return h(this.getTag(), attributes, children);
          },
          created: function created() {
            if (this.list !== null && this.value !== null) {
              helper["b"
              /* console */
              ].error("Value and list props are mutually exclusive! Please set one or another.");
            }

            if (this.element !== "div") {
              helper["b"
              /* console */
              ].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
            }

            if (this.options !== undefined) {
              helper["b"
              /* console */
              ].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
            }
          },
          mounted: function mounted() {
            var _this3 = this;

            this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();

            if (this.noneFunctionalComponentMode && this.transitionMode) {
              throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
            }

            var optionsAdded = {};
            eventsListened.forEach(function (elt) {
              optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
            });
            eventsToEmit.forEach(function (elt) {
              optionsAdded["on" + elt] = emit.bind(_this3, elt);
            });
            var attributes = Object.keys(this.$attrs).reduce(function (res, key) {
              res[Object(helper["a"
              /* camelize */
              ])(key)] = _this3.$attrs[key];
              return res;
            }, {});
            var options = Object.assign({}, this.options, attributes, optionsAdded, {
              onMove: function onMove(evt, originalEvent) {
                return _this3.onDragMove(evt, originalEvent);
              }
            });
            !("draggable" in options) && (options.draggable = ">*");
            this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
            this.computeIndexes();
          },
          beforeDestroy: function beforeDestroy() {
            if (this._sortable !== undefined) this._sortable.destroy();
          },
          computed: {
            rootContainer: function rootContainer() {
              return this.transitionMode ? this.$el.children[0] : this.$el;
            },
            realList: function realList() {
              return this.list ? this.list : this.value;
            }
          },
          watch: {
            options: {
              handler: function handler(newOptionValue) {
                this.updateOptions(newOptionValue);
              },
              deep: true
            },
            $attrs: {
              handler: function handler(newOptionValue) {
                this.updateOptions(newOptionValue);
              },
              deep: true
            },
            realList: function realList() {
              this.computeIndexes();
            }
          },
          methods: {
            getIsFunctional: function getIsFunctional() {
              var fnOptions = this._vnode.fnOptions;
              return fnOptions && fnOptions.functional;
            },
            getTag: function getTag() {
              return this.tag || this.element;
            },
            updateOptions: function updateOptions(newOptionValue) {
              for (var property in newOptionValue) {
                var value = Object(helper["a"
                /* camelize */
                ])(property);

                if (readonlyProperties.indexOf(value) === -1) {
                  this._sortable.option(value, newOptionValue[property]);
                }
              }
            },
            getChildrenNodes: function getChildrenNodes() {
              if (this.noneFunctionalComponentMode) {
                return this.$children[0].$slots["default"];
              }

              var rawNodes = this.$slots["default"];
              return this.transitionMode ? rawNodes[0].child.$slots["default"] : rawNodes;
            },
            computeIndexes: function computeIndexes() {
              var _this4 = this;

              this.$nextTick(function () {
                _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
              });
            },
            getUnderlyingVm: function getUnderlyingVm(htmlElt) {
              var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

              if (index === -1) {
                //Edge case during move callback: related element might be
                //an element different from collection
                return null;
              }

              var element = this.realList[index];
              return {
                index: index,
                element: element
              };
            },
            getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {
              var vue = _ref.__vue__;

              if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {
                if (!("realList" in vue) && vue.$children.length === 1 && "realList" in vue.$children[0]) return vue.$children[0];
                return vue;
              }

              return vue.$parent;
            },
            emitChanges: function emitChanges(evt) {
              var _this5 = this;

              this.$nextTick(function () {
                _this5.$emit("change", evt);
              });
            },
            alterList: function alterList(onList) {
              if (this.list) {
                onList(this.list);
                return;
              }

              var newList = _toConsumableArray(this.value);

              onList(newList);
              this.$emit("input", newList);
            },
            spliceList: function spliceList() {
              var _arguments = arguments;

              var spliceList = function spliceList(list) {
                return list.splice.apply(list, _toConsumableArray(_arguments));
              };

              this.alterList(spliceList);
            },
            updatePosition: function updatePosition(oldIndex, newIndex) {
              var updatePosition = function updatePosition(list) {
                return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
              };

              this.alterList(updatePosition);
            },
            getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {
              var to = _ref2.to,
                  related = _ref2.related;
              var component = this.getUnderlyingPotencialDraggableComponent(to);

              if (!component) {
                return {
                  component: component
                };
              }

              var list = component.realList;
              var context = {
                list: list,
                component: component
              };

              if (to !== related && list && component.getUnderlyingVm) {
                var destination = component.getUnderlyingVm(related);

                if (destination) {
                  return Object.assign(destination, context);
                }
              }

              return context;
            },
            getVmIndex: function getVmIndex(domIndex) {
              var indexes = this.visibleIndexes;
              var numberIndexes = indexes.length;
              return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
            },
            getComponent: function getComponent() {
              return this.$slots["default"][0].componentInstance;
            },
            resetTransitionData: function resetTransitionData(index) {
              if (!this.noTransitionOnDrag || !this.transitionMode) {
                return;
              }

              var nodes = this.getChildrenNodes();
              nodes[index].data = null;
              var transitionContainer = this.getComponent();
              transitionContainer.children = [];
              transitionContainer.kept = undefined;
            },
            onDragStart: function onDragStart(evt) {
              this.context = this.getUnderlyingVm(evt.item);
              evt.item._underlying_vm_ = this.clone(this.context.element);
              draggingElement = evt.item;
            },
            onDragAdd: function onDragAdd(evt) {
              var element = evt.item._underlying_vm_;

              if (element === undefined) {
                return;
              }

              Object(helper["d"
              /* removeNode */
              ])(evt.item);
              var newIndex = this.getVmIndex(evt.newIndex);
              this.spliceList(newIndex, 0, element);
              this.computeIndexes();
              var added = {
                element: element,
                newIndex: newIndex
              };
              this.emitChanges({
                added: added
              });
            },
            onDragRemove: function onDragRemove(evt) {
              Object(helper["c"
              /* insertNodeAt */
              ])(this.rootContainer, evt.item, evt.oldIndex);

              if (evt.pullMode === "clone") {
                Object(helper["d"
                /* removeNode */
                ])(evt.clone);
                return;
              }

              var oldIndex = this.context.index;
              this.spliceList(oldIndex, 1);
              var removed = {
                element: this.context.element,
                oldIndex: oldIndex
              };
              this.resetTransitionData(oldIndex);
              this.emitChanges({
                removed: removed
              });
            },
            onDragUpdate: function onDragUpdate(evt) {
              Object(helper["d"
              /* removeNode */
              ])(evt.item);
              Object(helper["c"
              /* insertNodeAt */
              ])(evt.from, evt.item, evt.oldIndex);
              var oldIndex = this.context.index;
              var newIndex = this.getVmIndex(evt.newIndex);
              this.updatePosition(oldIndex, newIndex);
              var moved = {
                element: this.context.element,
                oldIndex: oldIndex,
                newIndex: newIndex
              };
              this.emitChanges({
                moved: moved
              });
            },
            updateProperty: function updateProperty(evt, propertyName) {
              evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
            },
            computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
              if (!relatedContext.element) {
                return 0;
              }

              var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
                return el.style["display"] !== "none";
              });

              var currentDOMIndex = domChildren.indexOf(evt.related);
              var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
              var draggedInList = domChildren.indexOf(draggingElement) !== -1;
              return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
            },
            onDragMove: function onDragMove(evt, originalEvent) {
              var onMove = this.move;

              if (!onMove || !this.realList) {
                return true;
              }

              var relatedContext = this.getRelatedContextFromMoveEvent(evt);
              var draggedContext = this.context;
              var futureIndex = this.computeFutureIndex(relatedContext, evt);
              Object.assign(draggedContext, {
                futureIndex: futureIndex
              });
              var sendEvt = Object.assign({}, evt, {
                relatedContext: relatedContext,
                draggedContext: draggedContext
              });
              return onMove(sendEvt, originalEvent);
            },
            onDragEnd: function onDragEnd() {
              this.computeIndexes();
              draggingElement = null;
            }
          }
        };

        if (typeof window !== "undefined" && "Vue" in window) {
          window.Vue.component("draggable", draggableComponent);
        }
        /* harmony default export */


        var vuedraggable = draggableComponent; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

        /* harmony default export */

        var entry_lib = __webpack_exports__["default"] = vuedraggable;
        /***/
      }
      /******/

    })["default"]
  );
});

/***/ }),

/***/ 911:
/***/ (() => {

window.mainEventHub = {
  emit: function emit(hub, event) {
    if (window.mainEventHub[hub] == undefined) window.mainEventHub[hub] = new Vue();

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return window.mainEventHub[hub].$emit(event, args);
  },
  on: function on(hub, event, callback) {
    if (window.mainEventHub[hub] == undefined) window.mainEventHub[hub] = new Vue();
    return window.mainEventHub[hub].$on(event, callback);
  },
  off: function off(hub, event, callback) {
    if (window.mainEventHub[hub] == undefined) window.mainEventHub[hub] = new Vue();
    return window.mainEventHub[hub].$off(event, callback);
  }
};

Vue.prototype.$hubEmit = function (hub, event) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  return window.mainEventHub.emit(hub, event, args);
};

Vue.prototype.$hubOn = function (hub, event, callback) {
  return window.mainEventHub.on(hub, event, callback);
};

Vue.prototype.$hubOff = function (hub, event, callback) {
  return window.mainEventHub.off(hub, event, callback);
};

/***/ }),

/***/ 507:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ PageLoader)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./vendor/3xw/cakephp-pages/resources/assets/components/PageLoader.vue?vue&type=template&id=b71a5b92&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    _vm.componentInstance,
    _vm._b(
      { tag: "component", attrs: { slot: _vm.$slots[0] }, slot: _vm.$slots[0] },
      "component",
      _vm.attributes,
      false
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./vendor/3xw/cakephp-pages/resources/assets/components/PageLoader.vue?vue&type=template&id=b71a5b92&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1[0].rules[0].use!./node_modules/vue-loader/lib/index.js??vue-loader-options!./vendor/3xw/cakephp-pages/resources/assets/components/PageLoader.vue?vue&type=script&lang=js&
//
//
//
//
//
/* harmony default export */ const PageLoadervue_type_script_lang_js_ = ({
  props: {
    name: {
      type: String,
      "default": 'null'
    },
    props: {
      type: String
    }
  },
  created: function created() {},
  computed: {
    componentInstance: function componentInstance() {
      if (this.name == 'null') {
        return null;
      }

      var name = this.camelize(this.name.substring(this.name.indexOf('-') + 1));
      return function () {
        return __webpack_require__(730)("./".concat(name, ".vue"));
      };
    },
    attributes: function attributes() {
      var baseObj = JSON.parse(this.props);
      var obj = {};

      for (var i in baseObj) {
        if (i.substr(0, 1) == ':') {
          var prop = i.substr(1);
          obj[prop] = baseObj[i];
        } else obj[i] = baseObj[i];
      }

      return obj;
    }
  },
  methods: {
    camelize: function camelize(str) {
      return str.replace(/(?:^\w|[A-Z]|-|\b\w)/g, function (word, index) {
        return word.toUpperCase();
      }).replace(/\s+/g, '');
    }
  }
});
;// CONCATENATED MODULE: ./vendor/3xw/cakephp-pages/resources/assets/components/PageLoader.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_PageLoadervue_type_script_lang_js_ = (PageLoadervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(900);
;// CONCATENATED MODULE: ./vendor/3xw/cakephp-pages/resources/assets/components/PageLoader.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  components_PageLoadervue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "vendor/3xw/cakephp-pages/resources/assets/components/PageLoader.vue"
/* harmony default export */ const PageLoader = (component.exports);

/***/ }),

/***/ 900:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./List.vue": [
		44,
		600,
		547
	],
	"./ListItem.vue": [
		906,
		600,
		73
	],
	"./Page.vue": [
		592,
		600,
		654
	],
	"./PageArticlesHandler.vue": [
		314,
		600,
		691
	],
	"./PageInput.vue": [
		605,
		305
	],
	"./PageLoader.vue": [
		507
	],
	"./PageSection.vue": [
		634,
		600,
		812
	],
	"./PageSectionHandler.vue": [
		780,
		417
	],
	"./SectionModal.vue": [
		924,
		600,
		354
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = 730;
module.exports = webpackAsyncContext;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "js/pages/components/" + __webpack_require__.h() + "." + ({"73":"ListItem-vue","305":"PageInput-vue","354":"SectionModal-vue","417":"PageSectionHandler-vue","547":"List-vue","654":"Page-vue","691":"PageArticlesHandler-vue","812":"PageSection-vue"}[chunkId] || chunkId) + ".min.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if (chunkId === 179) return "css/pages/main.min.css";
/******/ 			// return url for filenames based on template
/******/ 			return "css/pages/components/" + ({"73":"ListItem-vue","305":"PageInput-vue","354":"SectionModal-vue","417":"PageSectionHandler-vue","547":"List-vue","654":"Page-vue","691":"PageArticlesHandler-vue","812":"PageSection-vue"}[chunkId] || chunkId) + ".min.css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("dfafa2346f7b025ab9dc")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "cake-webpack:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/cakephp-app/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// Promise = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			179: 0
/******/ 		};
/******/ 		
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => {
/******/ 								installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 							});
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no deferred startup
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0, resolves = [];
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					resolves.push(installedChunks[chunkId][0]);
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			while(resolves.length) {
/******/ 				resolves.shift()();
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkcake_webpack"] = self["webpackChunkcake_webpack"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 		
/******/ 		// no deferred startup
/******/ 	})();
/******/ 	
/************************************************************************/
(() => {
"use strict";
/* harmony import */ var _components_PageLoader_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(507);
/* harmony import */ var vuedraggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var vuedraggable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vuedraggable__WEBPACK_IMPORTED_MODULE_1__);
//JS
__webpack_require__(911);



Vue.component('PageLoader', _components_PageLoader_vue__WEBPACK_IMPORTED_MODULE_0__.default);
Vue.component((vuedraggable__WEBPACK_IMPORTED_MODULE_1___default()));
})();

(() => {
"use strict";
// extracted by mini-css-extract-plugin

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svLi9ub2RlX21vZHVsZXMvc29ydGFibGVqcy9tb2R1bGFyL3NvcnRhYmxlLmVzbS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZHZhbmNlLXN0cmluZy1pbmRleC5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2s6L3Z1ZWRyYWdnYWJsZS9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwic29ydGFibGVqc1wiLFwiY29tbW9uanMyXCI6XCJzb3J0YWJsZWpzXCIsXCJhbWRcIjpcInNvcnRhYmxlanNcIixcInJvb3RcIjpcIlNvcnRhYmxlXCJ9Iiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL3NyYy91dGlsL2hlbHBlci5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY3VycmVudC1zY3JpcHQtcG9seWZpbGwvY3VycmVudFNjcmlwdC5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL3NldFB1YmxpY1BhdGguanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svdnVlZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3Z1ZWRyYWdnYWJsZS9zcmMvdnVlZHJhZ2dhYmxlLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay92dWVkcmFnZ2FibGUvbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL2VudHJ5LWxpYi5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svLi92ZW5kb3IvM3h3L2Nha2VwaHAtcGFnZXMvcmVzb3VyY2VzL2Fzc2V0cy91dGlscy93aW5kb3ctZXZlbnRzLWh1Yi1ob29rcy5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svLi92ZW5kb3IvM3h3L2Nha2VwaHAtcGFnZXMvcmVzb3VyY2VzL2Fzc2V0cy9jb21wb25lbnRzL1BhZ2VMb2FkZXIudnVlP2JhODUiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3ZlbmRvci8zeHcvY2FrZXBocC1wYWdlcy9yZXNvdXJjZXMvYXNzZXRzL2NvbXBvbmVudHMvUGFnZUxvYWRlci52dWUiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrLy4vdmVuZG9yLzN4dy9jYWtlcGhwLXBhZ2VzL3Jlc291cmNlcy9hc3NldHMvY29tcG9uZW50cy9QYWdlTG9hZGVyLnZ1ZT84MjRmIiwid2VicGFjazovL2Nha2Utd2VicGFjay8uL3ZlbmRvci8zeHcvY2FrZXBocC1wYWdlcy9yZXNvdXJjZXMvYXNzZXRzL2NvbXBvbmVudHMvUGFnZUxvYWRlci52dWUiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svLi92ZW5kb3IvM3h3L2Nha2VwaHAtcGFnZXMvcmVzb3VyY2VzL2Fzc2V0cy9jb21wb25lbnRzfGxhenl8L15cXC5cXC8uKlxcLnZ1ZSQvfGNodW5rTmFtZTogW3JlcXVlc3RdfGdyb3VwT3B0aW9uczoge318bmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2Nha2Utd2VicGFjay93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svd2VicGFjay9ydW50aW1lL2dldCBtaW5pLWNzcyBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svd2VicGFjay9ydW50aW1lL2dldEZ1bGxIYXNoIiwid2VicGFjazovL2Nha2Utd2VicGFjay93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2Nha2Utd2VicGFjay93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vY2FrZS13ZWJwYWNrL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL2Nha2Utd2VicGFjay93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9jYWtlLXdlYnBhY2svLi92ZW5kb3IvM3h3L2Nha2VwaHAtcGFnZXMvcmVzb3VyY2VzL2Fzc2V0cy9tYWluLmpzIiwid2VicGFjazovL2Nha2Utd2VicGFjay8uL3ZlbmRvci8zeHcvY2FrZXBocC1wYWdlcy9yZXNvdXJjZXMvYXNzZXRzL2Fzc2V0cy9zY3NzL3RoZW1lLnNjc3MiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJjb25jYXQiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJmb3JFYWNoIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIkFycmF5IiwiaXNBcnJheSIsImFycjIiLCJpdGVyIiwidG9TdHJpbmciLCJmcm9tIiwiVHlwZUVycm9yIiwidmVyc2lvbiIsInVzZXJBZ2VudCIsInBhdHRlcm4iLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJtYXRjaCIsIklFMTFPckxlc3MiLCJFZGdlIiwiRmlyZUZveCIsIlNhZmFyaSIsIklPUyIsIkNocm9tZUZvckFuZHJvaWQiLCJjYXB0dXJlTW9kZSIsImNhcHR1cmUiLCJwYXNzaXZlIiwib24iLCJlbCIsImV2ZW50IiwiZm4iLCJhZGRFdmVudExpc3RlbmVyIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1hdGNoZXMiLCJzZWxlY3RvciIsInN1YnN0cmluZyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiXyIsImdldFBhcmVudE9ySG9zdCIsImhvc3QiLCJkb2N1bWVudCIsIm5vZGVUeXBlIiwicGFyZW50Tm9kZSIsImNsb3Nlc3QiLCJjdHgiLCJpbmNsdWRlQ1RYIiwiUl9TUEFDRSIsInRvZ2dsZUNsYXNzIiwibmFtZSIsInN0YXRlIiwiY2xhc3NMaXN0IiwiY2xhc3NOYW1lIiwicmVwbGFjZSIsImNzcyIsInByb3AiLCJ2YWwiLCJzdHlsZSIsImRlZmF1bHRWaWV3IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsIm1hdHJpeCIsInNlbGZPbmx5IiwiYXBwbGllZFRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJtYXRyaXhGbiIsIkRPTU1hdHJpeCIsIldlYktpdENTU01hdHJpeCIsIkNTU01hdHJpeCIsIk1TQ1NTTWF0cml4IiwiZmluZCIsInRhZ05hbWUiLCJsaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJuIiwiZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRSZWN0IiwicmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayIsInJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQiLCJ1bmRvU2NhbGUiLCJjb250YWluZXIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJlbFJlY3QiLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJoZWlnaHQiLCJ3aWR0aCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsImNvbnRhaW5lclJlY3QiLCJwYXJzZUludCIsImVsTWF0cml4Iiwic2NhbGVYIiwiYSIsInNjYWxlWSIsImQiLCJpc1Njcm9sbGVkUGFzdCIsImVsU2lkZSIsInBhcmVudFNpZGUiLCJwYXJlbnQiLCJnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudCIsImVsU2lkZVZhbCIsInBhcmVudFNpZGVWYWwiLCJ2aXNpYmxlIiwiZ2V0Q2hpbGQiLCJjaGlsZE51bSIsIm9wdGlvbnMiLCJjdXJyZW50Q2hpbGQiLCJjaGlsZHJlbiIsImRpc3BsYXkiLCJTb3J0YWJsZSIsImdob3N0IiwiZHJhZ2dlZCIsImRyYWdnYWJsZSIsImxhc3RDaGlsZCIsImxhc3QiLCJsYXN0RWxlbWVudENoaWxkIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImluZGV4Iiwibm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsImNsb25lIiwiZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwid2luU2Nyb2xsZXIiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiaW5kZXhPZk9iamVjdCIsIk51bWJlciIsImluY2x1ZGVTZWxmIiwiZWxlbSIsImdvdFNlbGYiLCJjbGllbnRXaWR0aCIsInNjcm9sbFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiZWxlbUNTUyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImJvZHkiLCJleHRlbmQiLCJkc3QiLCJzcmMiLCJpc1JlY3RFcXVhbCIsInJlY3QxIiwicmVjdDIiLCJNYXRoIiwicm91bmQiLCJfdGhyb3R0bGVUaW1lb3V0IiwidGhyb3R0bGUiLCJjYWxsYmFjayIsIm1zIiwiYXJncyIsIl90aGlzIiwic2V0VGltZW91dCIsImNhbmNlbFRocm90dGxlIiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsQnkiLCJ4IiwieSIsIlBvbHltZXIiLCIkIiwialF1ZXJ5IiwiWmVwdG8iLCJkb20iLCJjbG9uZU5vZGUiLCJzZXRSZWN0IiwicmVjdCIsInVuc2V0UmVjdCIsImV4cGFuZG8iLCJEYXRlIiwiZ2V0VGltZSIsIkFuaW1hdGlvblN0YXRlTWFuYWdlciIsImFuaW1hdGlvblN0YXRlcyIsImFuaW1hdGlvbkNhbGxiYWNrSWQiLCJjYXB0dXJlQW5pbWF0aW9uU3RhdGUiLCJhbmltYXRpb24iLCJzbGljZSIsImNoaWxkIiwicHVzaCIsImZyb21SZWN0IiwidGhpc0FuaW1hdGlvbkR1cmF0aW9uIiwiY2hpbGRNYXRyaXgiLCJmIiwiZSIsImFkZEFuaW1hdGlvblN0YXRlIiwicmVtb3ZlQW5pbWF0aW9uU3RhdGUiLCJzcGxpY2UiLCJhbmltYXRlQWxsIiwiYW5pbWF0aW5nIiwiYW5pbWF0aW9uVGltZSIsInRpbWUiLCJ0b1JlY3QiLCJwcmV2RnJvbVJlY3QiLCJwcmV2VG9SZWN0IiwiYW5pbWF0aW5nUmVjdCIsInRhcmdldE1hdHJpeCIsImNhbGN1bGF0ZVJlYWxUaW1lIiwiYW5pbWF0ZSIsIm1heCIsImFuaW1hdGlvblJlc2V0VGltZXIiLCJjdXJyZW50UmVjdCIsImR1cmF0aW9uIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJhbmltYXRpbmdYIiwiYW5pbWF0aW5nWSIsInJlcGFpbnQiLCJlYXNpbmciLCJhbmltYXRlZCIsIm9mZnNldFdpZHRoIiwic3FydCIsInBvdyIsInBsdWdpbnMiLCJkZWZhdWx0cyIsImluaXRpYWxpemVCeURlZmF1bHQiLCJQbHVnaW5NYW5hZ2VyIiwibW91bnQiLCJwbHVnaW4iLCJvcHRpb24iLCJwbHVnaW5FdmVudCIsImV2ZW50TmFtZSIsInNvcnRhYmxlIiwiZXZ0IiwiZXZlbnRDYW5jZWxlZCIsImNhbmNlbCIsImV2ZW50TmFtZUdsb2JhbCIsInBsdWdpbk5hbWUiLCJpbml0aWFsaXplUGx1Z2lucyIsImluaXRpYWxpemVkIiwibW9kaWZpZWQiLCJtb2RpZnlPcHRpb24iLCJnZXRFdmVudFByb3BlcnRpZXMiLCJldmVudFByb3BlcnRpZXMiLCJtb2RpZmllZFZhbHVlIiwib3B0aW9uTGlzdGVuZXJzIiwiZGlzcGF0Y2hFdmVudCIsIl9yZWYiLCJyb290RWwiLCJ0YXJnZXRFbCIsImNsb25lRWwiLCJ0b0VsIiwiZnJvbUVsIiwib2xkSW5kZXgiLCJuZXdJbmRleCIsIm9sZERyYWdnYWJsZUluZGV4IiwibmV3RHJhZ2dhYmxlSW5kZXgiLCJvcmlnaW5hbEV2ZW50IiwicHV0U29ydGFibGUiLCJleHRyYUV2ZW50UHJvcGVydGllcyIsIm9uTmFtZSIsImNoYXJBdCIsInN1YnN0ciIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInRvIiwiaXRlbSIsInB1bGxNb2RlIiwibGFzdFB1dE1vZGUiLCJ1bmRlZmluZWQiLCJhbGxFdmVudFByb3BlcnRpZXMiLCJkYXRhIiwiYmluZCIsImRyYWdFbCIsInBhcmVudEVsIiwiZ2hvc3RFbCIsIm5leHRFbCIsImxhc3REb3duRWwiLCJjbG9uZUhpZGRlbiIsImRyYWdTdGFydGVkIiwibW92ZWQiLCJhY3RpdmVTb3J0YWJsZSIsImFjdGl2ZSIsImhpZGVHaG9zdEZvclRhcmdldCIsIl9oaWRlR2hvc3RGb3JUYXJnZXQiLCJ1bmhpZGVHaG9zdEZvclRhcmdldCIsIl91bmhpZGVHaG9zdEZvclRhcmdldCIsImNsb25lTm93SGlkZGVuIiwiY2xvbmVOb3dTaG93biIsImRpc3BhdGNoU29ydGFibGVFdmVudCIsIl9kaXNwYXRjaEV2ZW50IiwiaW5mbyIsImFjdGl2ZUdyb3VwIiwiYXdhaXRpbmdEcmFnU3RhcnRlZCIsImlnbm9yZU5leHRDbGljayIsInNvcnRhYmxlcyIsInRhcEV2dCIsInRvdWNoRXZ0IiwibGFzdER4IiwibGFzdER5IiwidGFwRGlzdGFuY2VMZWZ0IiwidGFwRGlzdGFuY2VUb3AiLCJsYXN0VGFyZ2V0IiwibGFzdERpcmVjdGlvbiIsInBhc3RGaXJzdEludmVydFRocmVzaCIsImlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQiLCJ0YXJnZXRNb3ZlRGlzdGFuY2UiLCJnaG9zdFJlbGF0aXZlUGFyZW50IiwiZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwiLCJfc2lsZW50Iiwic2F2ZWRJbnB1dENoZWNrZWQiLCJkb2N1bWVudEV4aXN0cyIsIlBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5IiwiQ1NTRmxvYXRQcm9wZXJ0eSIsInN1cHBvcnREcmFnZ2FibGUiLCJjcmVhdGVFbGVtZW50Iiwic3VwcG9ydENzc1BvaW50ZXJFdmVudHMiLCJjc3NUZXh0IiwicG9pbnRlckV2ZW50cyIsIl9kZXRlY3REaXJlY3Rpb24iLCJlbENTUyIsImVsV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJjaGlsZDEiLCJjaGlsZDIiLCJmaXJzdENoaWxkQ1NTIiwic2Vjb25kQ2hpbGRDU1MiLCJmaXJzdENoaWxkV2lkdGgiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJzZWNvbmRDaGlsZFdpZHRoIiwiZmxleERpcmVjdGlvbiIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJzcGxpdCIsInRvdWNoaW5nU2lkZUNoaWxkMiIsImNsZWFyIiwiX2RyYWdFbEluUm93Q29sdW1uIiwiZHJhZ1JlY3QiLCJ0YXJnZXRSZWN0IiwidmVydGljYWwiLCJkcmFnRWxTMU9wcCIsImRyYWdFbFMyT3BwIiwiZHJhZ0VsT3BwTGVuZ3RoIiwidGFyZ2V0UzFPcHAiLCJ0YXJnZXRTMk9wcCIsInRhcmdldE9wcExlbmd0aCIsIl9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSIsInJldCIsInNvbWUiLCJ0aHJlc2hvbGQiLCJlbXB0eUluc2VydFRocmVzaG9sZCIsImluc2lkZUhvcml6b250YWxseSIsImluc2lkZVZlcnRpY2FsbHkiLCJfcHJlcGFyZUdyb3VwIiwidG9GbiIsInB1bGwiLCJzYW1lR3JvdXAiLCJncm91cCIsIm90aGVyR3JvdXAiLCJqb2luIiwib3JpZ2luYWxHcm91cCIsImNoZWNrUHVsbCIsImNoZWNrUHV0IiwicHV0IiwicmV2ZXJ0Q2xvbmUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50IiwidG91Y2hlcyIsIm5lYXJlc3QiLCJjbGllbnRYIiwiY2xpZW50WSIsIl9vbkRyYWdPdmVyIiwiX2NoZWNrT3V0c2lkZVRhcmdldEVsIiwiX2lzT3V0c2lkZVRoaXNFbCIsInNvcnQiLCJkaXNhYmxlZCIsInN0b3JlIiwiaGFuZGxlIiwidGVzdCIsInN3YXBUaHJlc2hvbGQiLCJpbnZlcnRTd2FwIiwiaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIiwicmVtb3ZlQ2xvbmVPbkhpZGUiLCJkaXJlY3Rpb24iLCJnaG9zdENsYXNzIiwiY2hvc2VuQ2xhc3MiLCJkcmFnQ2xhc3MiLCJpZ25vcmUiLCJwcmV2ZW50T25GaWx0ZXIiLCJzZXREYXRhIiwiZGF0YVRyYW5zZmVyIiwidGV4dENvbnRlbnQiLCJkcm9wQnViYmxlIiwiZHJhZ292ZXJCdWJibGUiLCJkYXRhSWRBdHRyIiwiZGVsYXkiLCJkZWxheU9uVG91Y2hPbmx5IiwidG91Y2hTdGFydFRocmVzaG9sZCIsImRldmljZVBpeGVsUmF0aW8iLCJmb3JjZUZhbGxiYWNrIiwiZmFsbGJhY2tDbGFzcyIsImZhbGxiYWNrT25Cb2R5IiwiZmFsbGJhY2tUb2xlcmFuY2UiLCJmYWxsYmFja09mZnNldCIsInN1cHBvcnRQb2ludGVyIiwibmF0aXZlRHJhZ2dhYmxlIiwiX29uVGFwU3RhcnQiLCJnZXQiLCJjb250YWlucyIsIl9nZXREaXJlY3Rpb24iLCJ0eXBlIiwidG91Y2giLCJwb2ludGVyVHlwZSIsIm9yaWdpbmFsVGFyZ2V0Iiwic2hhZG93Um9vdCIsInBhdGgiLCJjb21wb3NlZFBhdGgiLCJfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlIiwiYnV0dG9uIiwiaXNDb250ZW50RWRpdGFibGUiLCJjcml0ZXJpYSIsInRyaW0iLCJfcHJlcGFyZURyYWdTdGFydCIsIm93bmVyRG9jdW1lbnQiLCJkcmFnU3RhcnRGbiIsIm5leHRTaWJsaW5nIiwiX2xhc3RYIiwiX2xhc3RZIiwiX29uRHJvcCIsIl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMiLCJfdHJpZ2dlckRyYWdTdGFydCIsIl9kaXNhYmxlRHJhZ2dhYmxlIiwiX2Rpc2FibGVEZWxheWVkRHJhZyIsIl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIiLCJfZHJhZ1N0YXJ0VGltZXIiLCJhYnMiLCJmbG9vciIsIl9vblRvdWNoTW92ZSIsIl9vbkRyYWdTdGFydCIsInNlbGVjdGlvbiIsIl9uZXh0VGljayIsImVtcHR5IiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiZXJyIiwiX2RyYWdTdGFydGVkIiwiZmFsbGJhY2siLCJfYXBwZW5kR2hvc3QiLCJfbnVsbGluZyIsIl9lbXVsYXRlRHJhZ092ZXIiLCJlbGVtZW50RnJvbVBvaW50IiwiaW5zZXJ0ZWQiLCJnaG9zdE1hdHJpeCIsInJlbGF0aXZlU2Nyb2xsT2Zmc2V0IiwiZHgiLCJkeSIsImIiLCJjIiwiY3NzTWF0cml4IiwiYXBwZW5kQ2hpbGQiLCJfaGlkZUNsb25lIiwiY2xvbmVJZCIsImluc2VydEJlZm9yZSIsIl9sb29wSWQiLCJzZXRJbnRlcnZhbCIsImVmZmVjdEFsbG93ZWQiLCJfZHJhZ1N0YXJ0SWQiLCJyZXZlcnQiLCJpc093bmVyIiwiY2FuU29ydCIsImZyb21Tb3J0YWJsZSIsImNvbXBsZXRlZEZpcmVkIiwiZHJhZ092ZXJFdmVudCIsImV4dHJhIiwiYXhpcyIsImNvbXBsZXRlZCIsIm9uTW92ZSIsImFmdGVyIiwiX29uTW92ZSIsImNoYW5nZWQiLCJpbnNlcnRpb24iLCJfc2hvd0Nsb25lIiwiX2lnbm9yZVdoaWxlQW5pbWF0aW5nIiwiZWxMYXN0Q2hpbGQiLCJfZ2hvc3RJc0xhc3QiLCJ0YXJnZXRCZWZvcmVGaXJzdFN3YXAiLCJkaWZmZXJlbnRMZXZlbCIsImRpZmZlcmVudFJvd0NvbCIsInNpZGUxIiwic2Nyb2xsZWRQYXN0VG9wIiwic2Nyb2xsQmVmb3JlIiwiX2dldFN3YXBEaXJlY3Rpb24iLCJzaWJsaW5nIiwiZHJhZ0luZGV4IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibW92ZVZlY3RvciIsIl91bnNpbGVudCIsIl9vZmZNb3ZlRXZlbnRzIiwiX29mZlVwRXZlbnRzIiwiY2xlYXJJbnRlcnZhbCIsIl9jYW5jZWxOZXh0VGljayIsInJlbW92ZUNoaWxkIiwic2F2ZSIsImNoZWNrZWQiLCJoYW5kbGVFdmVudCIsIl9nbG9iYWxEcmFnT3ZlciIsInRvQXJyYXkiLCJvcmRlciIsImdldEF0dHJpYnV0ZSIsIl9nZW5lcmF0ZUlkIiwiaXRlbXMiLCJpZCIsInNldCIsImNsb3Nlc3QkMSIsImRlc3Ryb3kiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlQXR0cmlidXRlIiwiZHJvcEVmZmVjdCIsIndpbGxJbnNlcnRBZnRlciIsIm9uTW92ZUZuIiwicmV0VmFsIiwiZHJhZ2dlZFJlY3QiLCJyZWxhdGVkIiwicmVsYXRlZFJlY3QiLCJzcGFjZXIiLCJpc0xhc3RUYXJnZXQiLCJtb3VzZU9uQXhpcyIsInRhcmdldExlbmd0aCIsInRhcmdldFMxIiwidGFyZ2V0UzIiLCJpbnZlcnQiLCJfZ2V0SW5zZXJ0RGlyZWN0aW9uIiwic3RyIiwiaHJlZiIsInN1bSIsImNoYXJDb2RlQXQiLCJyb290IiwiaW5wdXRzIiwiaWR4IiwidXRpbHMiLCJpcyIsIm5leHRUaWNrIiwiY2FuY2VsTmV4dFRpY2siLCJkZXRlY3REaXJlY3Rpb24iLCJlbGVtZW50IiwiX2xlbiIsIl9rZXkiLCJjcmVhdGUiLCJhdXRvU2Nyb2xscyIsInNjcm9sbEVsIiwic2Nyb2xsUm9vdEVsIiwic2Nyb2xsaW5nIiwibGFzdEF1dG9TY3JvbGxYIiwibGFzdEF1dG9TY3JvbGxZIiwidG91Y2hFdnQkMSIsInBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIiwiQXV0b1Njcm9sbFBsdWdpbiIsIkF1dG9TY3JvbGwiLCJzY3JvbGwiLCJzY3JvbGxTZW5zaXRpdml0eSIsInNjcm9sbFNwZWVkIiwiYnViYmxlU2Nyb2xsIiwiX2hhbmRsZUF1dG9TY3JvbGwiLCJfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsIiwiZHJhZ092ZXJDb21wbGV0ZWQiLCJfcmVmMiIsImRyYWdPdmVyQnViYmxlIiwiZHJvcCIsImNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwiLCJjbGVhckF1dG9TY3JvbGxzIiwibnVsbGluZyIsImF1dG9TY3JvbGwiLCJvZ0VsZW1TY3JvbGxlciIsIm5ld0VsZW0iLCJwaWQiLCJpc0ZhbGxiYWNrIiwic2VucyIsInNwZWVkIiwic2Nyb2xsVGhpc0luc3RhbmNlIiwic2Nyb2xsQ3VzdG9tRm4iLCJzY3JvbGxGbiIsImxheWVyc091dCIsImN1cnJlbnRQYXJlbnQiLCJjYW5TY3JvbGxYIiwiY2FuU2Nyb2xsWSIsInNjcm9sbFBvc1giLCJzY3JvbGxQb3NZIiwidngiLCJ2eSIsImxheWVyIiwic2Nyb2xsT2Zmc2V0WSIsInNjcm9sbE9mZnNldFgiLCJ0b1NvcnRhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJvblNwaWxsIiwiUmV2ZXJ0Iiwic3RhcnRJbmRleCIsImRyYWdTdGFydCIsIl9yZWYzIiwiUmVtb3ZlIiwiX3JlZjQiLCJwYXJlbnRTb3J0YWJsZSIsImxhc3RTd2FwRWwiLCJTd2FwUGx1Z2luIiwiU3dhcCIsInN3YXBDbGFzcyIsImRyYWdPdmVyVmFsaWQiLCJzd2FwIiwicHJldlN3YXBFbCIsInN3YXBOb2RlcyIsInN3YXBJdGVtIiwibjEiLCJuMiIsInAxIiwicDIiLCJpMSIsImkyIiwiaXNFcXVhbE5vZGUiLCJtdWx0aURyYWdFbGVtZW50cyIsIm11bHRpRHJhZ0Nsb25lcyIsImxhc3RNdWx0aURyYWdTZWxlY3QiLCJtdWx0aURyYWdTb3J0YWJsZSIsImluaXRpYWxGb2xkaW5nIiwiZm9sZGluZyIsImRyYWdFbCQxIiwiY2xvbmVzRnJvbVJlY3QiLCJjbG9uZXNIaWRkZW4iLCJNdWx0aURyYWdQbHVnaW4iLCJNdWx0aURyYWciLCJfZGVzZWxlY3RNdWx0aURyYWciLCJfY2hlY2tLZXlEb3duIiwiX2NoZWNrS2V5VXAiLCJzZWxlY3RlZENsYXNzIiwibXVsdGlEcmFnS2V5IiwibXVsdGlEcmFnRWxlbWVudCIsIm11bHRpRHJhZ0tleURvd24iLCJpc011bHRpRHJhZyIsImRlbGF5U3RhcnRHbG9iYWwiLCJkZWxheUVuZGVkIiwic2V0dXBDbG9uZSIsInNvcnRhYmxlSW5kZXgiLCJpbnNlcnRNdWx0aURyYWdDbG9uZXMiLCJzaG93Q2xvbmUiLCJoaWRlQ2xvbmUiLCJfcmVmNSIsImRyYWdTdGFydEdsb2JhbCIsIl9yZWY2IiwibXVsdGlEcmFnIiwiX3JlZjciLCJfdGhpczIiLCJyZW1vdmVNdWx0aURyYWdFbGVtZW50cyIsImRyYWdPdmVyIiwiX3JlZjgiLCJfcmVmOSIsImluc2VydE11bHRpRHJhZ0VsZW1lbnRzIiwiX3JlZjEwIiwiZHJhZ1JlY3RBYnNvbHV0ZSIsImNsb25lc0hpZGRlbkJlZm9yZSIsImRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZSIsIl9yZWYxMSIsImRyYWdNYXRyaXgiLCJkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlIiwiX3JlZjEyIiwib3JpZ2luYWxFdnQiLCJzaGlmdEtleSIsImxhc3RJbmRleCIsImN1cnJlbnRJbmRleCIsIm11bHRpRHJhZ0luZGV4IiwidXBkYXRlIiwibnVsbGluZ0dsb2JhbCIsImRlc3Ryb3lHbG9iYWwiLCJzaGlmdCIsInNlbGVjdCIsImRlc2VsZWN0IiwiX3RoaXMzIiwib2xkSW5kaWNpZXMiLCJuZXdJbmRpY2llcyIsImNsb25lcyIsInRvTG93ZXJDYXNlIiwiY2xvbmVzSW5zZXJ0ZWQiLCJlbGVtZW50c0luc2VydGVkIiwiZ2xvYmFsIiwiY29uc29sZSIsImdldENvbnNvbGUiLCJjYWNoZSIsImhpdCIsInJlZ2V4IiwiY2FtZWxpemUiLCJjYWNoZWQiLCJub2RlIiwicmVmTm9kZSIsInBvc2l0aW9uIiwiZmF0aGVyTm9kZSIsIm9iamVjdCIsImVsdCIsImVsbUZyb21Ob2RlcyIsImZvb3RlckluZGV4IiwicmF3SW5kZXhlcyIsImlzVHJhbnNpdGlvbiIsImluZCIsImV2dE5hbWUiLCJlbWl0Iiwic2xvdHMiLCJjb21wb25lbnRPcHRpb25zIiwiaXNUcmFuc2l0aW9uTmFtZSIsInNsb3QiLCJzY29wZWRTbG90IiwiaGVhZGVyT2Zmc2V0IiwiZm9vdGVyT2Zmc2V0IiwiaGVhZGVyIiwiZ2V0U2xvdCIsImZvb3RlciIsImF0dHJpYnV0ZXMiLCJidWlsZEF0dHJpYnV0ZSIsImF0dHJzIiwicmVzIiwiJGF0dHJzIiwiY29tcG9uZW50RGF0YSIsInByb3BzIiwiY29tcG9uZW50RGF0YUF0dHJzIiwiZXZlbnRzTGlzdGVuZWQiLCJldmVudHNUb0VtaXQiLCJyZWFkb25seVByb3BlcnRpZXMiLCJkcmFnZ2luZ0VsZW1lbnQiLCJyZXF1aXJlZCIsImRlZmF1bHQiLCJub1RyYW5zaXRpb25PbkRyYWciLCJ0YWciLCJtb3ZlIiwiZHJhZ2dhYmxlQ29tcG9uZW50IiwiaW5oZXJpdEF0dHJzIiwidHJhbnNpdGlvbk1vZGUiLCJub25lRnVuY3Rpb25hbENvbXBvbmVudE1vZGUiLCJyZW5kZXIiLCJjb21wdXRlQ2hpbGRyZW5BbmRPZmZzZXRzIiwiZ2V0Q29tcG9uZW50QXR0cmlidXRlcyIsImgiLCJjcmVhdGVkIiwibW91bnRlZCIsIm9wdGlvbnNBZGRlZCIsImRlbGVnYXRlQW5kRW1pdCIsImJlZm9yZURlc3Ryb3kiLCJjb21wdXRlZCIsInJvb3RDb250YWluZXIiLCJyZWFsTGlzdCIsIndhdGNoIiwiaGFuZGxlciIsImRlZXAiLCJtZXRob2RzIiwiZ2V0SXNGdW5jdGlvbmFsIiwiZm5PcHRpb25zIiwiZ2V0VGFnIiwidXBkYXRlT3B0aW9ucyIsIm5ld09wdGlvblZhbHVlIiwiZ2V0Q2hpbGRyZW5Ob2RlcyIsInJhd05vZGVzIiwiY29tcHV0ZUluZGV4ZXMiLCJnZXRVbmRlcmx5aW5nVm0iLCJjb21wdXRlVm1JbmRleCIsImdldFVuZGVybHlpbmdQb3RlbmNpYWxEcmFnZ2FibGVDb21wb25lbnQiLCJ2dWUiLCJfX3Z1ZV9fIiwiZW1pdENoYW5nZXMiLCJhbHRlckxpc3QiLCJvbkxpc3QiLCJuZXdMaXN0Iiwic3BsaWNlTGlzdCIsInVwZGF0ZVBvc2l0aW9uIiwiZ2V0UmVsYXRlZENvbnRleHRGcm9tTW92ZUV2ZW50IiwiY29tcG9uZW50IiwiY29udGV4dCIsImRlc3RpbmF0aW9uIiwiZ2V0Vm1JbmRleCIsImluZGV4ZXMiLCJudW1iZXJJbmRleGVzIiwiZG9tSW5kZXgiLCJnZXRDb21wb25lbnQiLCJyZXNldFRyYW5zaXRpb25EYXRhIiwibm9kZXMiLCJ0cmFuc2l0aW9uQ29udGFpbmVyIiwib25EcmFnU3RhcnQiLCJvbkRyYWdBZGQiLCJyZW1vdmVOb2RlIiwiYWRkZWQiLCJvbkRyYWdSZW1vdmUiLCJpbnNlcnROb2RlQXQiLCJyZW1vdmVkIiwib25EcmFnVXBkYXRlIiwidXBkYXRlUHJvcGVydHkiLCJjb21wdXRlRnV0dXJlSW5kZXgiLCJyZWxhdGVkQ29udGV4dCIsImRvbUNoaWxkcmVuIiwiY3VycmVudERPTUluZGV4IiwiZHJhZ2dlZEluTGlzdCIsIm9uRHJhZ01vdmUiLCJkcmFnZ2VkQ29udGV4dCIsImZ1dHVyZUluZGV4Iiwic2VuZEV2dCIsIm9uRHJhZ0VuZCIsIm1haW5FdmVudEh1YiIsImh1YiIsIlZ1ZSIsIiRlbWl0IiwiJG9uIiwiJG9mZiIsIiRodWJFbWl0IiwiJGh1Yk9uIiwiJGh1Yk9mZiIsInJlcXVpcmUiLCJQYWdlTG9hZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDcEIsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLFNBQU9BLE1BQU0sQ0FBQ0MsUUFBZCxNQUEyQixRQUEvRCxFQUF5RTtBQUN2RUgsV0FBTyxHQUFHLGlCQUFVQyxHQUFWLEVBQWU7QUFDdkIsc0JBQWNBLEdBQWQ7QUFDRCxLQUZEO0FBR0QsR0FKRCxNQUlPO0FBQ0xELFdBQU8sR0FBRyxpQkFBVUMsR0FBVixF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aW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4gKiBTb3J0YWJsZSAxLjEwLjJcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGF1dGhvclx0b3dlbm0gICAgPG93ZW4yMzM1NUBnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMS4xMC4yXCI7XG5cbmZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICEhXG4gICAgLypAX19QVVJFX18qL1xuICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gocGF0dGVybik7XG4gIH1cbn1cblxudmFyIElFMTFPckxlc3MgPSB1c2VyQWdlbnQoLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llfGllbW9iaWxlfFdpbmRvd3MgUGhvbmUpL2kpO1xudmFyIEVkZ2UgPSB1c2VyQWdlbnQoL0VkZ2UvaSk7XG52YXIgRmlyZUZveCA9IHVzZXJBZ2VudCgvZmlyZWZveC9pKTtcbnZhciBTYWZhcmkgPSB1c2VyQWdlbnQoL3NhZmFyaS9pKSAmJiAhdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgIXVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcbnZhciBJT1MgPSB1c2VyQWdlbnQoL2lQKGFkfG9kfGhvbmUpL2kpO1xudmFyIENocm9tZUZvckFuZHJvaWQgPSB1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiB1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG5cbnZhciBjYXB0dXJlTW9kZSA9IHtcbiAgY2FwdHVyZTogZmFsc2UsXG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcikge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG4gIHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcblxuICBpZiAoZWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGVsLm1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50T3JIb3N0KGVsKSB7XG4gIHJldHVybiBlbC5ob3N0ICYmIGVsICE9PSBkb2N1bWVudCAmJiBlbC5ob3N0Lm5vZGVUeXBlID8gZWwuaG9zdCA6IGVsLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcixcbi8qKkhUTUxFbGVtZW50Ki9cbmN0eCwgaW5jbHVkZUNUWCkge1xuICBpZiAoZWwpIHtcbiAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiAoc2VsZWN0b3JbMF0gPT09ICc+JyA/IGVsLnBhcmVudE5vZGUgPT09IGN0eCAmJiBtYXRjaGVzKGVsLCBzZWxlY3RvcikgOiBtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHx8IGluY2x1ZGVDVFggJiYgZWwgPT09IGN0eCkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbCA9PT0gY3R4KSBicmVhaztcbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB9IHdoaWxlIChlbCA9IGdldFBhcmVudE9ySG9zdChlbCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSX1NQQUNFID0gL1xccysvZztcblxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIHN0YXRlKSB7XG4gIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKFJfU1BBQ0UsICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuICAgICAgZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3NzKGVsLCBwcm9wLCB2YWwpIHtcbiAgdmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICB2YWwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWwgPSBlbC5jdXJyZW50U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wID09PSB2b2lkIDAgPyB2YWwgOiB2YWxbcHJvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHByb3AgaW4gc3R5bGUpICYmIHByb3AuaW5kZXhPZignd2Via2l0JykgPT09IC0xKSB7XG4gICAgICAgIHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRyaXgoZWwsIHNlbGZPbmx5KSB7XG4gIHZhciBhcHBsaWVkVHJhbnNmb3JtcyA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBwbGllZFRyYW5zZm9ybXMgPSBlbDtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY3NzKGVsLCAndHJhbnNmb3JtJyk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgIH0gd2hpbGUgKCFzZWxmT25seSAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICB2YXIgbWF0cml4Rm4gPSB3aW5kb3cuRE9NTWF0cml4IHx8IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggfHwgd2luZG93LkNTU01hdHJpeCB8fCB3aW5kb3cuTVNDU1NNYXRyaXg7XG4gIC8qanNoaW50IC1XMDU2ICovXG5cbiAgcmV0dXJuIG1hdHJpeEZuICYmIG5ldyBtYXRyaXhGbihhcHBsaWVkVHJhbnNmb3Jtcyk7XG59XG5cbmZ1bmN0aW9uIGZpbmQoY3R4LCB0YWdOYW1lLCBpdGVyYXRvcikge1xuICBpZiAoY3R4KSB7XG4gICAgdmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGxpc3RbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkge1xuICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgaWYgKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgXCJib3VuZGluZyBjbGllbnQgcmVjdFwiIG9mIGdpdmVuIGVsZW1lbnRcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgICAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZ0NsaWVudFJlY3QgaXMgd2FudGVkXHJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgYmxvY2sgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaW5lclxyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSByZWxhdGl2ZSBwYXJlbnQgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaWVuclxyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHVuZG9TY2FsZSAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGNvbnRhaW5lcidzIHNjYWxlKCkgc2hvdWxkIGJlIHVuZG9uZVxyXG4gKiBAcGFyYW0gIHtbSFRNTEVsZW1lbnRdfSBjb250YWluZXIgICAgICAgICAgICAgIFRoZSBwYXJlbnQgdGhlIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5cclxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYm91bmRpbmdDbGllbnRSZWN0IG9mIGVsLCB3aXRoIHNwZWNpZmllZCBhZGp1c3RtZW50c1xyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWN0KGVsLCByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrLCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50LCB1bmRvU2NhbGUsIGNvbnRhaW5lcikge1xuICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbCAhPT0gd2luZG93KSByZXR1cm47XG4gIHZhciBlbFJlY3QsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgaGVpZ2h0LCB3aWR0aDtcblxuICBpZiAoZWwgIT09IHdpbmRvdyAmJiBlbCAhPT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdG9wID0gZWxSZWN0LnRvcDtcbiAgICBsZWZ0ID0gZWxSZWN0LmxlZnQ7XG4gICAgYm90dG9tID0gZWxSZWN0LmJvdHRvbTtcbiAgICByaWdodCA9IGVsUmVjdC5yaWdodDtcbiAgICBoZWlnaHQgPSBlbFJlY3QuaGVpZ2h0O1xuICAgIHdpZHRoID0gZWxSZWN0LndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9IDA7XG4gICAgbGVmdCA9IDA7XG4gICAgYm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIH1cblxuICBpZiAoKHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCkgJiYgZWwgIT09IHdpbmRvdykge1xuICAgIC8vIEFkanVzdCBmb3IgdHJhbnNsYXRlKClcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZWwucGFyZW50Tm9kZTsgLy8gc29sdmVzICMxMTIzIChzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzk1MzgwNi82MDg4MzEyKVxuICAgIC8vIE5vdCBuZWVkZWQgb24gPD0gSUUxMVxuXG4gICAgaWYgKCFJRTExT3JMZXNzKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoY3NzKGNvbnRhaW5lciwgJ3RyYW5zZm9ybScpICE9PSAnbm9uZScgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAmJiBjc3MoY29udGFpbmVyLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFNldCByZWxhdGl2ZSB0byBlZGdlcyBvZiBwYWRkaW5nIGJveCBvZiBjb250YWluZXJcblxuICAgICAgICAgIHRvcCAtPSBjb250YWluZXJSZWN0LnRvcCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItdG9wLXdpZHRoJykpO1xuICAgICAgICAgIGxlZnQgLT0gY29udGFpbmVyUmVjdC5sZWZ0ICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci1sZWZ0LXdpZHRoJykpO1xuICAgICAgICAgIGJvdHRvbSA9IHRvcCArIGVsUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgZWxSZWN0LndpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgICAgfSB3aGlsZSAoY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bmRvU2NhbGUgJiYgZWwgIT09IHdpbmRvdykge1xuICAgIC8vIEFkanVzdCBmb3Igc2NhbGUoKVxuICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChjb250YWluZXIgfHwgZWwpLFxuICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kO1xuXG4gICAgaWYgKGVsTWF0cml4KSB7XG4gICAgICB0b3AgLz0gc2NhbGVZO1xuICAgICAgbGVmdCAvPSBzY2FsZVg7XG4gICAgICB3aWR0aCAvPSBzY2FsZVg7XG4gICAgICBoZWlnaHQgLz0gc2NhbGVZO1xuICAgICAgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgICAgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRvcCxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBzaWRlIG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgcGFzdCBhIHNpZGUgb2YgaXRzIHBhcmVudHNcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbCAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvJ3Mgc2lkZSBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBpcyBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIGVsU2lkZSAgICAgICBTaWRlIG9mIHRoZSBlbGVtZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBwYXJlbnRTaWRlICAgU2lkZSBvZiB0aGUgcGFyZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgICAgICAgVGhlIHBhcmVudCBzY3JvbGwgZWxlbWVudCB0aGF0IHRoZSBlbCdzIHNpZGUgaXMgc2Nyb2xsZWQgcGFzdCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIGVsZW1lbnRcclxuICovXG5cblxuZnVuY3Rpb24gaXNTY3JvbGxlZFBhc3QoZWwsIGVsU2lkZSwgcGFyZW50U2lkZSkge1xuICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIHRydWUpLFxuICAgICAgZWxTaWRlVmFsID0gZ2V0UmVjdChlbClbZWxTaWRlXTtcbiAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICB2YXIgcGFyZW50U2lkZVZhbCA9IGdldFJlY3QocGFyZW50KVtwYXJlbnRTaWRlXSxcbiAgICAgICAgdmlzaWJsZSA9IHZvaWQgMDtcblxuICAgIGlmIChwYXJlbnRTaWRlID09PSAndG9wJyB8fCBwYXJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPj0gcGFyZW50U2lkZVZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA8PSBwYXJlbnRTaWRlVmFsO1xuICAgIH1cblxuICAgIGlmICghdmlzaWJsZSkgcmV0dXJuIHBhcmVudDtcbiAgICBpZiAocGFyZW50ID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIGJyZWFrO1xuICAgIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHBhcmVudCwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXHJcbiAqIEdldHMgbnRoIGNoaWxkIG9mIGVsLCBpZ25vcmluZyBoaWRkZW4gY2hpbGRyZW4sIHNvcnRhYmxlJ3MgZWxlbWVudHMgKGRvZXMgbm90IGlnbm9yZSBjbG9uZSBpZiBpdCdzIHZpc2libGUpXHJcbiAqIGFuZCBub24tZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBUaGUgcGFyZW50IGVsZW1lbnRcclxuICogQHBhcmFtICB7TnVtYmVyfSBjaGlsZE51bSAgICAgIFRoZSBpbmRleCBvZiB0aGUgY2hpbGRcclxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAgICAgIFBhcmVudCBTb3J0YWJsZSdzIG9wdGlvbnNcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBjaGlsZCBhdCBpbmRleCBjaGlsZE51bSwgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQgPSAwLFxuICAgICAgaSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG4gIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZ2hvc3QgJiYgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmRyYWdnZWQgJiYgY2xvc2VzdChjaGlsZHJlbltpXSwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Q2hpbGQgPT09IGNoaWxkTnVtKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudENoaWxkKys7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcclxuICogR2V0cyB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgZWwsIGlnbm9yaW5nIGdob3N0RWwgb3IgaW52aXNpYmxlIGVsZW1lbnRzIChjbG9uZXMpXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3IgICAgQW55IG90aGVyIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBsYXN0IGNoaWxkLCBpZ25vcmluZyBnaG9zdEVsXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxhc3RDaGlsZChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGxhc3QgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xuXG4gIHdoaWxlIChsYXN0ICYmIChsYXN0ID09PSBTb3J0YWJsZS5naG9zdCB8fCBjc3MobGFzdCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNlbGVjdG9yICYmICFtYXRjaGVzKGxhc3QsIHNlbGVjdG9yKSkpIHtcbiAgICBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3QgfHwgbnVsbDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50IGZvciBhIHNlbGVjdGVkIHNldCBvZlxyXG4gKiBlbGVtZW50c1xyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXG5cblxuZnVuY3Rpb24gaW5kZXgoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgaWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cblxuICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdURU1QTEFURScgJiYgZWwgIT09IFNvcnRhYmxlLmNsb25lICYmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgc2Nyb2xsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgYWRkZWQgd2l0aCBhbGwgdGhlIHNjcm9sbCBvZmZzZXRzIG9mIHBhcmVudCBlbGVtZW50cy5cclxuICogVGhlIHZhbHVlIGlzIHJldHVybmVkIGluIHJlYWwgcGl4ZWxzLlxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIE9mZnNldHMgaW4gdGhlIGZvcm1hdCBvZiBbbGVmdCwgdG9wXVxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChlbCkge1xuICB2YXIgb2Zmc2V0TGVmdCA9IDAsXG4gICAgICBvZmZzZXRUb3AgPSAwLFxuICAgICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG5cbiAgaWYgKGVsKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGVsKSxcbiAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4LmQ7XG4gICAgICBvZmZzZXRMZWZ0ICs9IGVsLnNjcm9sbExlZnQgKiBzY2FsZVg7XG4gICAgICBvZmZzZXRUb3AgKz0gZWwuc2Nyb2xsVG9wICogc2NhbGVZO1xuICAgIH0gd2hpbGUgKGVsICE9PSB3aW5TY3JvbGxlciAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICByZXR1cm4gW29mZnNldExlZnQsIG9mZnNldFRvcF07XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCB3aXRoaW4gdGhlIGdpdmVuIGFycmF5XHJcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIgICBBcnJheSB0aGF0IG1heSBvciBtYXkgbm90IGhvbGQgdGhlIG9iamVjdFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgQW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5LXZhbHVlIHBhaXIgdW5pcXVlIHRvIGFuZCBpZGVudGljYWwgdG8gYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGZpbmRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSwgb3IgLTFcclxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZk9iamVjdChhcnIsIG9iaikge1xuICBmb3IgKHZhciBpIGluIGFycikge1xuICAgIGlmICghYXJyLmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSA9PT0gYXJyW2ldW2tleV0pIHJldHVybiBOdW1iZXIoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgaW5jbHVkZVNlbGYpIHtcbiAgLy8gc2tpcCB0byB3aW5kb3dcbiAgaWYgKCFlbCB8fCAhZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgZWxlbSA9IGVsO1xuICB2YXIgZ290U2VsZiA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGdldCBlbGVtIGNzcyBpZiBpdCBpc24ndCBldmVuIG92ZXJmbG93aW5nIGluIHRoZSBmaXJzdCBwbGFjZSAocGVyZm9ybWFuY2UpXG4gICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIHZhciBlbGVtQ1NTID0gY3NzKGVsZW0pO1xuXG4gICAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggJiYgKGVsZW1DU1Mub3ZlcmZsb3dYID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WCA9PSAnc2Nyb2xsJykgfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCAmJiAoZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dZID09ICdzY3JvbGwnKSkge1xuICAgICAgICBpZiAoIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHx8IGVsZW0gPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIGlmIChnb3RTZWxmIHx8IGluY2x1ZGVTZWxmKSByZXR1cm4gZWxlbTtcbiAgICAgICAgZ290U2VsZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB9IHdoaWxlIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKTtcblxuICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZHN0LCBzcmMpIHtcbiAgaWYgKGRzdCAmJiBzcmMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG5mdW5jdGlvbiBpc1JlY3RFcXVhbChyZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQocmVjdDEudG9wKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi50b3ApICYmIE1hdGgucm91bmQocmVjdDEubGVmdCkgPT09IE1hdGgucm91bmQocmVjdDIubGVmdCkgJiYgTWF0aC5yb3VuZChyZWN0MS5oZWlnaHQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmhlaWdodCkgJiYgTWF0aC5yb3VuZChyZWN0MS53aWR0aCkgPT09IE1hdGgucm91bmQocmVjdDIud2lkdGgpO1xufVxuXG52YXIgX3Rocm90dGxlVGltZW91dDtcblxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIG1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhyb3R0bGVUaW1lb3V0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgX3Rocm90dGxlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsVGhyb3R0bGUoKSB7XG4gIGNsZWFyVGltZW91dChfdGhyb3R0bGVUaW1lb3V0KTtcbiAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsQnkoZWwsIHgsIHkpIHtcbiAgZWwuc2Nyb2xsTGVmdCArPSB4O1xuICBlbC5zY3JvbGxUb3AgKz0geTtcbn1cblxuZnVuY3Rpb24gY2xvbmUoZWwpIHtcbiAgdmFyIFBvbHltZXIgPSB3aW5kb3cuUG9seW1lcjtcbiAgdmFyICQgPSB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0bztcblxuICBpZiAoUG9seW1lciAmJiBQb2x5bWVyLmRvbSkge1xuICAgIHJldHVybiBQb2x5bWVyLmRvbShlbCkuY2xvbmVOb2RlKHRydWUpO1xuICB9IGVsc2UgaWYgKCQpIHtcbiAgICByZXR1cm4gJChlbCkuY2xvbmUodHJ1ZSlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZWN0KGVsLCByZWN0KSB7XG4gIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gIGNzcyhlbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgY3NzKGVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gIGNzcyhlbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gIGNzcyhlbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gdW5zZXRSZWN0KGVsKSB7XG4gIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJycpO1xuICBjc3MoZWwsICd0b3AnLCAnJyk7XG4gIGNzcyhlbCwgJ2xlZnQnLCAnJyk7XG4gIGNzcyhlbCwgJ3dpZHRoJywgJycpO1xuICBjc3MoZWwsICdoZWlnaHQnLCAnJyk7XG59XG5cbnZhciBleHBhbmRvID0gJ1NvcnRhYmxlJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5mdW5jdGlvbiBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSB7XG4gIHZhciBhbmltYXRpb25TdGF0ZXMgPSBbXSxcbiAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQ7XG4gIHJldHVybiB7XG4gICAgY2FwdHVyZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBjYXB0dXJlQW5pbWF0aW9uU3RhdGUoKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbCh0aGlzLmVsLmNoaWxkcmVuKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjc3MoY2hpbGQsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBjaGlsZCA9PT0gU29ydGFibGUuZ2hvc3QpIHJldHVybjtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogY2hpbGQsXG4gICAgICAgICAgcmVjdDogZ2V0UmVjdChjaGlsZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZyb21SZWN0ID0gX29iamVjdFNwcmVhZCh7fSwgYW5pbWF0aW9uU3RhdGVzW2FuaW1hdGlvblN0YXRlcy5sZW5ndGggLSAxXS5yZWN0KTsgLy8gSWYgYW5pbWF0aW5nOiBjb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuXG5cbiAgICAgICAgaWYgKGNoaWxkLnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIHZhciBjaGlsZE1hdHJpeCA9IG1hdHJpeChjaGlsZCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGRNYXRyaXgpIHtcbiAgICAgICAgICAgIGZyb21SZWN0LnRvcCAtPSBjaGlsZE1hdHJpeC5mO1xuICAgICAgICAgICAgZnJvbVJlY3QubGVmdCAtPSBjaGlsZE1hdHJpeC5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLmZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFkZEFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBhZGRBbmltYXRpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH0sXG4gICAgcmVtb3ZlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIHJlbW92ZUFuaW1hdGlvblN0YXRlKHRhcmdldCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLnNwbGljZShpbmRleE9mT2JqZWN0KGFuaW1hdGlvblN0YXRlcywge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgfSksIDEpO1xuICAgIH0sXG4gICAgYW5pbWF0ZUFsbDogZnVuY3Rpb24gYW5pbWF0ZUFsbChjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5pbWF0aW5nID0gZmFsc2UsXG4gICAgICAgICAgYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICAgICAgZnJvbVJlY3QgPSB0YXJnZXQuZnJvbVJlY3QsXG4gICAgICAgICAgICB0b1JlY3QgPSBnZXRSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBwcmV2RnJvbVJlY3QgPSB0YXJnZXQucHJldkZyb21SZWN0LFxuICAgICAgICAgICAgcHJldlRvUmVjdCA9IHRhcmdldC5wcmV2VG9SZWN0LFxuICAgICAgICAgICAgYW5pbWF0aW5nUmVjdCA9IHN0YXRlLnJlY3QsXG4gICAgICAgICAgICB0YXJnZXRNYXRyaXggPSBtYXRyaXgodGFyZ2V0LCB0cnVlKTtcblxuICAgICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgICAgLy8gQ29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAgICB0b1JlY3QudG9wIC09IHRhcmdldE1hdHJpeC5mO1xuICAgICAgICAgIHRvUmVjdC5sZWZ0IC09IHRhcmdldE1hdHJpeC5lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICBpZiAodGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIC8vIENvdWxkIGFsc28gY2hlY2sgaWYgYW5pbWF0aW5nUmVjdCBpcyBiZXR3ZWVuIGZyb21SZWN0IGFuZCB0b1JlY3RcbiAgICAgICAgICBpZiAoaXNSZWN0RXF1YWwocHJldkZyb21SZWN0LCB0b1JlY3QpICYmICFpc1JlY3RFcXVhbChmcm9tUmVjdCwgdG9SZWN0KSAmJiAvLyBNYWtlIHN1cmUgYW5pbWF0aW5nUmVjdCBpcyBvbiBsaW5lIGJldHdlZW4gdG9SZWN0ICYgZnJvbVJlY3RcbiAgICAgICAgICAoYW5pbWF0aW5nUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChhbmltYXRpbmdSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgPT09IChmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpKSB7XG4gICAgICAgICAgICAvLyBJZiByZXR1cm5pbmcgdG8gc2FtZSBwbGFjZSBhcyBzdGFydGVkIGZyb20gYW5pbWF0aW9uIGFuZCBvbiBzYW1lIGF4aXNcbiAgICAgICAgICAgIHRpbWUgPSBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBwcmV2RnJvbVJlY3QsIHByZXZUb1JlY3QsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBmcm9tUmVjdCAhPSB0b1JlY3Q6IGFuaW1hdGVcblxuXG4gICAgICAgIGlmICghaXNSZWN0RXF1YWwodG9SZWN0LCBmcm9tUmVjdCkpIHtcbiAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5hbmltYXRlKHRhcmdldCwgYW5pbWF0aW5nUmVjdCwgdG9SZWN0LCB0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gTWF0aC5tYXgoYW5pbWF0aW9uVGltZSwgdGltZSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuZnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuXG4gICAgICBpZiAoIWFuaW1hdGluZykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIGFuaW1hdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUodGFyZ2V0LCBjdXJyZW50UmVjdCwgdG9SZWN0LCBkdXJhdGlvbikge1xuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgodGhpcy5lbCksXG4gICAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAoY3VycmVudFJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gKGN1cnJlbnRSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKHNjYWxlWSB8fCAxKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSAhIXRyYW5zbGF0ZVg7XG4gICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gISF0cmFuc2xhdGVZO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCcgKyB0cmFuc2xhdGVYICsgJ3B4LCcgKyB0cmFuc2xhdGVZICsgJ3B4LDApJyk7XG4gICAgICAgIHJlcGFpbnQodGFyZ2V0KTsgLy8gcmVwYWludFxuXG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ3RyYW5zZm9ybSAnICsgZHVyYXRpb24gKyAnbXMnICsgKHRoaXMub3B0aW9ucy5lYXNpbmcgPyAnICcgKyB0aGlzLm9wdGlvbnMuZWFzaW5nIDogJycpKTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICAgICAgdHlwZW9mIHRhcmdldC5hbmltYXRlZCA9PT0gJ251bWJlcicgJiYgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRlZCk7XG4gICAgICAgIHRhcmdldC5hbmltYXRlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSBmYWxzZTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWSA9IGZhbHNlO1xuICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXBhaW50KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0Lm9mZnNldFdpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBmcm9tUmVjdCwgdG9SZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gYW5pbWF0aW5nUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIGFuaW1hdGluZ1JlY3QubGVmdCwgMikpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0LCAyKSkgKiBvcHRpb25zLmFuaW1hdGlvbjtcbn1cblxudmFyIHBsdWdpbnMgPSBbXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxufTtcbnZhciBQbHVnaW5NYW5hZ2VyID0ge1xuICBtb3VudDogZnVuY3Rpb24gbW91bnQocGx1Z2luKSB7XG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGljIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBvcHRpb24gaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmICEob3B0aW9uIGluIHBsdWdpbikpIHtcbiAgICAgICAgcGx1Z2luW29wdGlvbl0gPSBkZWZhdWx0c1tvcHRpb25dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICB9LFxuICBwbHVnaW5FdmVudDogZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSwgZXZ0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZXZlbnRDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgZXZ0LmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmV2ZW50Q2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZXZlbnROYW1lR2xvYmFsID0gZXZlbnROYW1lICsgJ0dsb2JhbCc7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIEZpcmUgZ2xvYmFsIGV2ZW50cyBpZiBpdCBleGlzdHMgaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICBpZiAoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0pIHtcbiAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0oX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgIH0sIGV2dCkpO1xuICAgICAgfSAvLyBPbmx5IGZpcmUgcGx1Z2luIGV2ZW50IGlmIHBsdWdpbiBpcyBlbmFibGVkIGluIHRoaXMgc29ydGFibGUsXG4gICAgICAvLyBhbmQgcGx1Z2luIGhhcyBldmVudCBkZWZpbmVkXG5cblxuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luLnBsdWdpbk5hbWVdICYmIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaW5pdGlhbGl6ZVBsdWdpbnM6IGZ1bmN0aW9uIGluaXRpYWxpemVQbHVnaW5zKHNvcnRhYmxlLCBlbCwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZTtcbiAgICAgIGlmICghc29ydGFibGUub3B0aW9uc1twbHVnaW5OYW1lXSAmJiAhcGx1Z2luLmluaXRpYWxpemVCeURlZmF1bHQpIHJldHVybjtcbiAgICAgIHZhciBpbml0aWFsaXplZCA9IG5ldyBwbHVnaW4oc29ydGFibGUsIGVsLCBzb3J0YWJsZS5vcHRpb25zKTtcbiAgICAgIGluaXRpYWxpemVkLnNvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICBpbml0aWFsaXplZC5vcHRpb25zID0gc29ydGFibGUub3B0aW9ucztcbiAgICAgIHNvcnRhYmxlW3BsdWdpbk5hbWVdID0gaW5pdGlhbGl6ZWQ7IC8vIEFkZCBkZWZhdWx0IG9wdGlvbnMgZnJvbSBwbHVnaW5cblxuICAgICAgX2V4dGVuZHMoZGVmYXVsdHMsIGluaXRpYWxpemVkLmRlZmF1bHRzKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIG9wdGlvbiBpbiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkgY29udGludWU7XG4gICAgICB2YXIgbW9kaWZpZWQgPSB0aGlzLm1vZGlmeU9wdGlvbihzb3J0YWJsZSwgb3B0aW9uLCBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0pO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0gPSBtb2RpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldEV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSB7XG4gICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHt9O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5ldmVudFByb3BlcnRpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgX2V4dGVuZHMoZXZlbnRQcm9wZXJ0aWVzLCBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50UHJvcGVydGllcztcbiAgfSxcbiAgbW9kaWZ5T3B0aW9uOiBmdW5jdGlvbiBtb2RpZnlPcHRpb24oc29ydGFibGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWU7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIC8vIFBsdWdpbiBtdXN0IGV4aXN0IG9uIHRoZSBTb3J0YWJsZVxuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gSWYgc3RhdGljIG9wdGlvbiBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgb3B0aW9uLCBjYWxsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBTb3J0YWJsZSdzIGluc3RhbmNlIG9mIHRoaXMgcGx1Z2luXG5cbiAgICAgIGlmIChwbHVnaW4ub3B0aW9uTGlzdGVuZXJzICYmIHR5cGVvZiBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkVmFsdWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoX3JlZikge1xuICB2YXIgc29ydGFibGUgPSBfcmVmLnNvcnRhYmxlLFxuICAgICAgcm9vdEVsID0gX3JlZi5yb290RWwsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgdGFyZ2V0RWwgPSBfcmVmLnRhcmdldEVsLFxuICAgICAgY2xvbmVFbCA9IF9yZWYuY2xvbmVFbCxcbiAgICAgIHRvRWwgPSBfcmVmLnRvRWwsXG4gICAgICBmcm9tRWwgPSBfcmVmLmZyb21FbCxcbiAgICAgIG9sZEluZGV4ID0gX3JlZi5vbGRJbmRleCxcbiAgICAgIG5ld0luZGV4ID0gX3JlZi5uZXdJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZi5vbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gX3JlZi5uZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBleHRyYUV2ZW50UHJvcGVydGllcyA9IF9yZWYuZXh0cmFFdmVudFByb3BlcnRpZXM7XG4gIHNvcnRhYmxlID0gc29ydGFibGUgfHwgcm9vdEVsICYmIHJvb3RFbFtleHBhbmRvXTtcbiAgaWYgKCFzb3J0YWJsZSkgcmV0dXJuO1xuICB2YXIgZXZ0LFxuICAgICAgb3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXG4gICAgICBvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZXZ0LnRvID0gdG9FbCB8fCByb290RWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcbiAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gIGV2dC5jbG9uZSA9IGNsb25lRWw7XG4gIGV2dC5vbGRJbmRleCA9IG9sZEluZGV4O1xuICBldnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgZXZ0Lm9sZERyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5uZXdEcmFnZ2FibGVJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4O1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGV2dC5wdWxsTW9kZSA9IHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUubGFzdFB1dE1vZGUgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGFsbEV2ZW50UHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQoe30sIGV4dHJhRXZlbnRQcm9wZXJ0aWVzLCBQbHVnaW5NYW5hZ2VyLmdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkpO1xuXG4gIGZvciAodmFyIG9wdGlvbiBpbiBhbGxFdmVudFByb3BlcnRpZXMpIHtcbiAgICBldnRbb3B0aW9uXSA9IGFsbEV2ZW50UHJvcGVydGllc1tvcHRpb25dO1xuICB9XG5cbiAgaWYgKHJvb3RFbCkge1xuICAgIHJvb3RFbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cblxuICBpZiAob3B0aW9uc1tvbk5hbWVdKSB7XG4gICAgb3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XG4gIH1cbn1cblxudmFyIHBsdWdpbkV2ZW50ID0gZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5ldnQsXG4gICAgICBkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImV2dFwiXSk7XG5cbiAgUGx1Z2luTWFuYWdlci5wbHVnaW5FdmVudC5iaW5kKFNvcnRhYmxlKShldmVudE5hbWUsIHNvcnRhYmxlLCBfb2JqZWN0U3ByZWFkKHtcbiAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICBwYXJlbnRFbDogcGFyZW50RWwsXG4gICAgZ2hvc3RFbDogZ2hvc3RFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBuZXh0RWw6IG5leHRFbCxcbiAgICBsYXN0RG93bkVsOiBsYXN0RG93bkVsLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW46IGNsb25lSGlkZGVuLFxuICAgIGRyYWdTdGFydGVkOiBtb3ZlZCxcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgYWN0aXZlU29ydGFibGU6IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICBoaWRlR2hvc3RGb3JUYXJnZXQ6IF9oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQ6IF91bmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICBjbG9uZU5vd0hpZGRlbjogZnVuY3Rpb24gY2xvbmVOb3dIaWRkZW4oKSB7XG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfSxcbiAgICBjbG9uZU5vd1Nob3duOiBmdW5jdGlvbiBjbG9uZU5vd1Nob3duKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9LFxuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KG5hbWUpIHtcbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGRhdGEpKTtcbn07XG5cbmZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGluZm8pIHtcbiAgZGlzcGF0Y2hFdmVudChfb2JqZWN0U3ByZWFkKHtcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICB0YXJnZXRFbDogZHJhZ0VsLFxuICAgIHJvb3RFbDogcm9vdEVsLFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleFxuICB9LCBpbmZvKSk7XG59XG5cbnZhciBkcmFnRWwsXG4gICAgcGFyZW50RWwsXG4gICAgZ2hvc3RFbCxcbiAgICByb290RWwsXG4gICAgbmV4dEVsLFxuICAgIGxhc3REb3duRWwsXG4gICAgY2xvbmVFbCxcbiAgICBjbG9uZUhpZGRlbixcbiAgICBvbGRJbmRleCxcbiAgICBuZXdJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICBhY3RpdmVHcm91cCxcbiAgICBwdXRTb3J0YWJsZSxcbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2UsXG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2UsXG4gICAgc29ydGFibGVzID0gW10sXG4gICAgdGFwRXZ0LFxuICAgIHRvdWNoRXZ0LFxuICAgIGxhc3REeCxcbiAgICBsYXN0RHksXG4gICAgdGFwRGlzdGFuY2VMZWZ0LFxuICAgIHRhcERpc3RhbmNlVG9wLFxuICAgIG1vdmVkLFxuICAgIGxhc3RUYXJnZXQsXG4gICAgbGFzdERpcmVjdGlvbixcbiAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZSxcbiAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2UsXG4gICAgdGFyZ2V0TW92ZURpc3RhbmNlLFxuICAgIC8vIEZvciBwb3NpdGlvbmluZyBnaG9zdCBhYnNvbHV0ZWx5XG5naG9zdFJlbGF0aXZlUGFyZW50LFxuICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gW10sXG4gICAgLy8gKGxlZnQsIHRvcClcbl9zaWxlbnQgPSBmYWxzZSxcbiAgICBzYXZlZElucHV0Q2hlY2tlZCA9IFtdO1xuLyoqIEBjb25zdCAqL1xuXG52YXIgZG9jdW1lbnRFeGlzdHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICAgIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID0gSU9TLFxuICAgIENTU0Zsb2F0UHJvcGVydHkgPSBFZGdlIHx8IElFMTFPckxlc3MgPyAnY3NzRmxvYXQnIDogJ2Zsb2F0JyxcbiAgICAvLyBUaGlzIHdpbGwgbm90IHBhc3MgZm9yIElFOSwgYmVjYXVzZSBJRTkgRG5EIG9ubHkgd29ya3Mgb24gYW5jaG9yc1xuc3VwcG9ydERyYWdnYWJsZSA9IGRvY3VtZW50RXhpc3RzICYmICFDaHJvbWVGb3JBbmRyb2lkICYmICFJT1MgJiYgJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZG9jdW1lbnRFeGlzdHMpIHJldHVybjsgLy8gZmFsc2Ugd2hlbiA8PSBJRTExXG5cbiAgaWYgKElFMTFPckxlc3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XG4gIGVsLnN0eWxlLmNzc1RleHQgPSAncG9pbnRlci1ldmVudHM6YXV0byc7XG4gIHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XG59KCksXG4gICAgX2RldGVjdERpcmVjdGlvbiA9IGZ1bmN0aW9uIF9kZXRlY3REaXJlY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgIGVsV2lkdGggPSBwYXJzZUludChlbENTUy53aWR0aCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nTGVmdCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nUmlnaHQpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyTGVmdFdpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlclJpZ2h0V2lkdGgpLFxuICAgICAgY2hpbGQxID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMpLFxuICAgICAgY2hpbGQyID0gZ2V0Q2hpbGQoZWwsIDEsIG9wdGlvbnMpLFxuICAgICAgZmlyc3RDaGlsZENTUyA9IGNoaWxkMSAmJiBjc3MoY2hpbGQxKSxcbiAgICAgIHNlY29uZENoaWxkQ1NTID0gY2hpbGQyICYmIGNzcyhjaGlsZDIpLFxuICAgICAgZmlyc3RDaGlsZFdpZHRoID0gZmlyc3RDaGlsZENTUyAmJiBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMSkud2lkdGgsXG4gICAgICBzZWNvbmRDaGlsZFdpZHRoID0gc2Vjb25kQ2hpbGRDU1MgJiYgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMikud2lkdGg7XG5cbiAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdmbGV4Jykge1xuICAgIHJldHVybiBlbENTUy5mbGV4RGlyZWN0aW9uID09PSAnY29sdW1uJyB8fCBlbENTUy5mbGV4RGlyZWN0aW9uID09PSAnY29sdW1uLXJldmVyc2UnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfVxuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZ3JpZCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZ3JpZFRlbXBsYXRlQ29sdW1ucy5zcGxpdCgnICcpLmxlbmd0aCA8PSAxID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfVxuXG4gIGlmIChjaGlsZDEgJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAhPT0gJ25vbmUnKSB7XG4gICAgdmFyIHRvdWNoaW5nU2lkZUNoaWxkMiA9IGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICByZXR1cm4gY2hpbGQyICYmIChzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gJ2JvdGgnIHx8IHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSB0b3VjaGluZ1NpZGVDaGlsZDIpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfVxuXG4gIHJldHVybiBjaGlsZDEgJiYgKGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdmbGV4JyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICd0YWJsZScgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZ3JpZCcgfHwgZmlyc3RDaGlsZFdpZHRoID49IGVsV2lkdGggJiYgZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyB8fCBjaGlsZDIgJiYgZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyAmJiBmaXJzdENoaWxkV2lkdGggKyBzZWNvbmRDaGlsZFdpZHRoID4gZWxXaWR0aCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xufSxcbiAgICBfZHJhZ0VsSW5Sb3dDb2x1bW4gPSBmdW5jdGlvbiBfZHJhZ0VsSW5Sb3dDb2x1bW4oZHJhZ1JlY3QsIHRhcmdldFJlY3QsIHZlcnRpY2FsKSB7XG4gIHZhciBkcmFnRWxTMU9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QubGVmdCA6IGRyYWdSZWN0LnRvcCxcbiAgICAgIGRyYWdFbFMyT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5yaWdodCA6IGRyYWdSZWN0LmJvdHRvbSxcbiAgICAgIGRyYWdFbE9wcExlbmd0aCA9IHZlcnRpY2FsID8gZHJhZ1JlY3Qud2lkdGggOiBkcmFnUmVjdC5oZWlnaHQsXG4gICAgICB0YXJnZXRTMU9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5sZWZ0IDogdGFyZ2V0UmVjdC50b3AsXG4gICAgICB0YXJnZXRTMk9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5yaWdodCA6IHRhcmdldFJlY3QuYm90dG9tLFxuICAgICAgdGFyZ2V0T3BwTGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LndpZHRoIDogdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gIHJldHVybiBkcmFnRWxTMU9wcCA9PT0gdGFyZ2V0UzFPcHAgfHwgZHJhZ0VsUzJPcHAgPT09IHRhcmdldFMyT3BwIHx8IGRyYWdFbFMxT3BwICsgZHJhZ0VsT3BwTGVuZ3RoIC8gMiA9PT0gdGFyZ2V0UzFPcHAgKyB0YXJnZXRPcHBMZW5ndGggLyAyO1xufSxcblxuLyoqXG4gKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cbiAqIEBwYXJhbSAge051bWJlcn0geCAgICAgIFggcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0geSAgICAgIFkgcG9zaXRpb25cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcbiAqL1xuX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlID0gZnVuY3Rpb24gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKHgsIHkpIHtcbiAgdmFyIHJldDtcbiAgc29ydGFibGVzLnNvbWUoZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgaWYgKGxhc3RDaGlsZChzb3J0YWJsZSkpIHJldHVybjtcbiAgICB2YXIgcmVjdCA9IGdldFJlY3Qoc29ydGFibGUpLFxuICAgICAgICB0aHJlc2hvbGQgPSBzb3J0YWJsZVtleHBhbmRvXS5vcHRpb25zLmVtcHR5SW5zZXJ0VGhyZXNob2xkLFxuICAgICAgICBpbnNpZGVIb3Jpem9udGFsbHkgPSB4ID49IHJlY3QubGVmdCAtIHRocmVzaG9sZCAmJiB4IDw9IHJlY3QucmlnaHQgKyB0aHJlc2hvbGQsXG4gICAgICAgIGluc2lkZVZlcnRpY2FsbHkgPSB5ID49IHJlY3QudG9wIC0gdGhyZXNob2xkICYmIHkgPD0gcmVjdC5ib3R0b20gKyB0aHJlc2hvbGQ7XG5cbiAgICBpZiAodGhyZXNob2xkICYmIGluc2lkZUhvcml6b250YWxseSAmJiBpbnNpZGVWZXJ0aWNhbGx5KSB7XG4gICAgICByZXR1cm4gcmV0ID0gc29ydGFibGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn0sXG4gICAgX3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JvdXAob3B0aW9ucykge1xuICBmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgZHJhZ0VsLCBldnQpIHtcbiAgICAgIHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiYgZnJvbS5vcHRpb25zLmdyb3VwLm5hbWUgJiYgdG8ub3B0aW9ucy5ncm91cC5uYW1lID09PSBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xuICAgICAgICAvLyBEZWZhdWx0IHB1bGwgdmFsdWVcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIGFuZCBwdXQgdmFsdWUgaWYgc2FtZSBncm91cFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwdWxsICYmIHZhbHVlID09PSAnY2xvbmUnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3RoZXJHcm91cCA9IChwdWxsID8gdG8gOiBmcm9tKS5vcHRpb25zLmdyb3VwLm5hbWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwIHx8IHZhbHVlLmpvaW4gJiYgdmFsdWUuaW5kZXhPZihvdGhlckdyb3VwKSA+IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZ3JvdXAgPSB7fTtcbiAgdmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuXG4gIGlmICghb3JpZ2luYWxHcm91cCB8fCBfdHlwZW9mKG9yaWdpbmFsR3JvdXApICE9ICdvYmplY3QnKSB7XG4gICAgb3JpZ2luYWxHcm91cCA9IHtcbiAgICAgIG5hbWU6IG9yaWdpbmFsR3JvdXBcbiAgICB9O1xuICB9XG5cbiAgZ3JvdXAubmFtZSA9IG9yaWdpbmFsR3JvdXAubmFtZTtcbiAgZ3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xuICBncm91cC5jaGVja1B1dCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdXQpO1xuICBncm91cC5yZXZlcnRDbG9uZSA9IG9yaWdpbmFsR3JvdXAucmV2ZXJ0Q2xvbmU7XG4gIG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcbn0sXG4gICAgX2hpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF9oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICdub25lJyk7XG4gIH1cbn0sXG4gICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIH1cbn07IC8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxuXG5cbmlmIChkb2N1bWVudEV4aXN0cykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoaWdub3JlTmV4dENsaWNrKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuXG52YXIgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XG5cbiAgICB2YXIgbmVhcmVzdCA9IF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZShldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgaWYgKG5lYXJlc3QpIHtcbiAgICAgIC8vIENyZWF0ZSBpbWl0YXRpb24gZXZlbnRcbiAgICAgIHZhciBldmVudCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIGV2dCkge1xuICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgZXZlbnRbaV0gPSBldnRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQucm9vdEVsID0gbmVhcmVzdDtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gdm9pZCAwO1xuXG4gICAgICBuZWFyZXN0W2V4cGFuZG9dLl9vbkRyYWdPdmVyKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwgPSBmdW5jdGlvbiBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuICB9XG59O1xuLyoqXG4gKiBAY2xhc3MgIFNvcnRhYmxlXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxuICovXG5cblxuZnVuY3Rpb24gU29ydGFibGUoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XG4gICAgdGhyb3cgXCJTb3J0YWJsZTogYGVsYCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50LCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwoZWwpKTtcbiAgfVxuXG4gIHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTsgLy8gRXhwb3J0IGluc3RhbmNlXG5cbiAgZWxbZXhwYW5kb10gPSB0aGlzO1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZ3JvdXA6IG51bGwsXG4gICAgc29ydDogdHJ1ZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc3RvcmU6IG51bGwsXG4gICAgaGFuZGxlOiBudWxsLFxuICAgIGRyYWdnYWJsZTogL15bdW9dbCQvaS50ZXN0KGVsLm5vZGVOYW1lKSA/ICc+bGknIDogJz4qJyxcbiAgICBzd2FwVGhyZXNob2xkOiAxLFxuICAgIC8vIHBlcmNlbnRhZ2U7IDAgPD0geCA8PSAxXG4gICAgaW52ZXJ0U3dhcDogZmFsc2UsXG4gICAgLy8gaW52ZXJ0IGFsd2F5c1xuICAgIGludmVydGVkU3dhcFRocmVzaG9sZDogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCB0byBzYW1lIGFzIHN3YXBUaHJlc2hvbGQgaWYgZGVmYXVsdFxuICAgIHJlbW92ZUNsb25lT25IaWRlOiB0cnVlLFxuICAgIGRpcmVjdGlvbjogZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9kZXRlY3REaXJlY3Rpb24oZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgICBnaG9zdENsYXNzOiAnc29ydGFibGUtZ2hvc3QnLFxuICAgIGNob3NlbkNsYXNzOiAnc29ydGFibGUtY2hvc2VuJyxcbiAgICBkcmFnQ2xhc3M6ICdzb3J0YWJsZS1kcmFnJyxcbiAgICBpZ25vcmU6ICdhLCBpbWcnLFxuICAgIGZpbHRlcjogbnVsbCxcbiAgICBwcmV2ZW50T25GaWx0ZXI6IHRydWUsXG4gICAgYW5pbWF0aW9uOiAwLFxuICAgIGVhc2luZzogbnVsbCxcbiAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRyYWdFbC50ZXh0Q29udGVudCk7XG4gICAgfSxcbiAgICBkcm9wQnViYmxlOiBmYWxzZSxcbiAgICBkcmFnb3ZlckJ1YmJsZTogZmFsc2UsXG4gICAgZGF0YUlkQXR0cjogJ2RhdGEtaWQnLFxuICAgIGRlbGF5OiAwLFxuICAgIGRlbGF5T25Ub3VjaE9ubHk6IGZhbHNlLFxuICAgIHRvdWNoU3RhcnRUaHJlc2hvbGQ6IChOdW1iZXIucGFyc2VJbnQgPyBOdW1iZXIgOiB3aW5kb3cpLnBhcnNlSW50KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxMCkgfHwgMSxcbiAgICBmb3JjZUZhbGxiYWNrOiBmYWxzZSxcbiAgICBmYWxsYmFja0NsYXNzOiAnc29ydGFibGUtZmFsbGJhY2snLFxuICAgIGZhbGxiYWNrT25Cb2R5OiBmYWxzZSxcbiAgICBmYWxsYmFja1RvbGVyYW5jZTogMCxcbiAgICBmYWxsYmFja09mZnNldDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIHN1cHBvcnRQb2ludGVyOiBTb3J0YWJsZS5zdXBwb3J0UG9pbnRlciAhPT0gZmFsc2UgJiYgJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93LFxuICAgIGVtcHR5SW5zZXJ0VGhyZXNob2xkOiA1XG4gIH07XG4gIFBsdWdpbk1hbmFnZXIuaW5pdGlhbGl6ZVBsdWdpbnModGhpcywgZWwsIGRlZmF1bHRzKTsgLy8gU2V0IGRlZmF1bHQgb3B0aW9uc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XG4gIH1cblxuICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpOyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuXG4gIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgfVxuICB9IC8vIFNldHVwIGRyYWcgbW9kZVxuXG5cbiAgdGhpcy5uYXRpdmVEcmFnZ2FibGUgPSBvcHRpb25zLmZvcmNlRmFsbGJhY2sgPyBmYWxzZSA6IHN1cHBvcnREcmFnZ2FibGU7XG5cbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgLy8gVG91Y2ggc3RhcnQgdGhyZXNob2xkIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG5hdGl2ZSBkcmFnc3RhcnQgdGhyZXNob2xkXG4gICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSAxO1xuICB9IC8vIEJpbmQgZXZlbnRzXG5cblxuICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgIG9uKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBvbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9uKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICB9XG5cbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgb24oZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgIG9uKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gIH1cblxuICBzb3J0YWJsZXMucHVzaCh0aGlzLmVsKTsgLy8gUmVzdG9yZSBzb3J0aW5nXG5cbiAgb3B0aW9ucy5zdG9yZSAmJiBvcHRpb25zLnN0b3JlLmdldCAmJiB0aGlzLnNvcnQob3B0aW9ucy5zdG9yZS5nZXQodGhpcykgfHwgW10pOyAvLyBBZGQgYW5pbWF0aW9uIHN0YXRlIG1hbmFnZXJcblxuICBfZXh0ZW5kcyh0aGlzLCBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSk7XG59XG5cblNvcnRhYmxlLnByb3RvdHlwZSA9XG4vKiogQGxlbmRzIFNvcnRhYmxlLnByb3RvdHlwZSAqL1xue1xuICBjb25zdHJ1Y3RvcjogU29ydGFibGUsXG4gIF9pc091dHNpZGVUaGlzRWw6IGZ1bmN0aW9uIF9pc091dHNpZGVUaGlzRWwodGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKHRhcmdldCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmVsKSB7XG4gICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIF9nZXREaXJlY3Rpb246IGZ1bmN0aW9uIF9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIGRyYWdFbCkgOiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB9LFxuICBfb25UYXBTdGFydDogZnVuY3Rpb24gX29uVGFwU3RhcnQoXG4gIC8qKiBFdmVudHxUb3VjaEV2ZW50ICovXG4gIGV2dCkge1xuICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybjtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcHJldmVudE9uRmlsdGVyID0gb3B0aW9ucy5wcmV2ZW50T25GaWx0ZXIsXG4gICAgICAgIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSB8fCBldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICYmIGV2dCxcbiAgICAgICAgdGFyZ2V0ID0gKHRvdWNoIHx8IGV2dCkudGFyZ2V0LFxuICAgICAgICBvcmlnaW5hbFRhcmdldCA9IGV2dC50YXJnZXQuc2hhZG93Um9vdCAmJiAoZXZ0LnBhdGggJiYgZXZ0LnBhdGhbMF0gfHwgZXZ0LmNvbXBvc2VkUGF0aCAmJiBldnQuY29tcG9zZWRQYXRoKClbMF0pIHx8IHRhcmdldCxcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG5cbiAgICBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTsgLy8gRG9uJ3QgdHJpZ2dlciBzdGFydCBldmVudCB3aGVuIGFuIGVsZW1lbnQgaXMgYmVlbiBkcmFnZ2VkLCBvdGhlcndpc2UgdGhlIGV2dC5vbGRpbmRleCBhbHdheXMgd3Jvbmcgd2hlbiBzZXQgb3B0aW9uLmdyb3VwLlxuXG5cbiAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QodHlwZSkgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47IC8vIG9ubHkgbGVmdCBidXR0b24gYW5kIGVuYWJsZWRcbiAgICB9IC8vIGNhbmNlbCBkbmQgaWYgb3JpZ2luYWwgdGFyZ2V0IGlzIGNvbnRlbnQgZWRpdGFibGVcblxuXG4gICAgaWYgKG9yaWdpbmFsVGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpO1xuXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyBJZ25vcmluZyBkdXBsaWNhdGUgYGRvd25gXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuXG4gICAgb2xkSW5kZXggPSBpbmRleCh0YXJnZXQpO1xuICAgIG9sZERyYWdnYWJsZUluZGV4ID0gaW5kZXgodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSk7IC8vIENoZWNrIGZpbHRlclxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICByb290RWw6IG9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgZnJvbUVsOiBlbFxuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgY3JpdGVyaWEgPSBjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGNyaXRlcmlhKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgcm9vdEVsOiBjcml0ZXJpYSxcbiAgICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICB0b0VsOiBlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZSAmJiAhY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFByZXBhcmUgYGRyYWdzdGFydGBcblxuXG4gICAgdGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQpO1xuICB9LFxuICBfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gX3ByZXBhcmVEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCxcbiAgLyoqIEhUTUxFbGVtZW50ICovXG4gIHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gX3RoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBvd25lckRvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgZHJhZ1N0YXJ0Rm47XG5cbiAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICByb290RWwgPSBlbDtcbiAgICAgIGRyYWdFbCA9IHRhcmdldDtcbiAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7XG4gICAgICBuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG4gICAgICBsYXN0RG93bkVsID0gdGFyZ2V0O1xuICAgICAgYWN0aXZlR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgICAgU29ydGFibGUuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICAgIHRhcEV2dCA9IHtcbiAgICAgICAgdGFyZ2V0OiBkcmFnRWwsXG4gICAgICAgIGNsaWVudFg6ICh0b3VjaCB8fCBldnQpLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0YXBEaXN0YW5jZUxlZnQgPSB0YXBFdnQuY2xpZW50WCAtIGRyYWdSZWN0LmxlZnQ7XG4gICAgICB0YXBEaXN0YW5jZVRvcCA9IHRhcEV2dC5jbGllbnRZIC0gZHJhZ1JlY3QudG9wO1xuICAgICAgdGhpcy5fbGFzdFggPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRZO1xuICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XG5cbiAgICAgIGRyYWdTdGFydEZuID0gZnVuY3Rpb24gZHJhZ1N0YXJ0Rm4oKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdkZWxheUVuZGVkJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIF90aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgIC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxuXG5cbiAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgICAgIGlmICghRmlyZUZveCAmJiBfdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG5cblxuICAgICAgICBfdGhpcy5fdHJpZ2dlckRyYWdTdGFydChldnQsIHRvdWNoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2hvb3NlJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7IC8vIENob3NlbiBpdGVtXG5cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xuICAgICAgfTsgLy8gRGlzYWJsZSBcImRyYWdnYWJsZVwiXG5cblxuICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBmaW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7IC8vIE1ha2UgZHJhZ0VsIGRyYWdnYWJsZSAobXVzdCBiZSBiZWZvcmUgZGVsYXkgZm9yIEZpcmVGb3gpXG5cbiAgICAgIGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gNDtcbiAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbkV2ZW50KCdkZWxheVN0YXJ0JywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7IC8vIERlbGF5IGlzIGltcG9zc2libGUgZm9yIG5hdGl2ZSBEbkQgaW4gRWRnZSBvciBJRVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiAoIW9wdGlvbnMuZGVsYXlPblRvdWNoT25seSB8fCB0b3VjaCkgJiYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCAhKEVkZ2UgfHwgSUUxMU9yTGVzcykpKSB7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuICAgICAgICAvLyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuXG5cbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0UG9pbnRlciAmJiBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgX3RoaXMuX2RyYWdTdGFydFRpbWVyID0gc2V0VGltZW91dChkcmFnU3RhcnRGbiwgb3B0aW9ucy5kZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnU3RhcnRGbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcjogZnVuY3Rpb24gX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcihcbiAgLyoqIFRvdWNoRXZlbnR8UG9pbnRlckV2ZW50ICoqL1xuICBlKSB7XG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgIGlmIChNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA+PSBNYXRoLmZsb29yKHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkIC8gKHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSkge1xuICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKCk7XG4gICAgfVxuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnKCkge1xuICAgIGRyYWdFbCAmJiBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gIH0sXG4gIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfdHJpZ2dlckRyYWdTdGFydChcbiAgLyoqIEV2ZW50ICovXG4gIGV2dCxcbiAgLyoqIFRvdWNoICovXG4gIHRvdWNoKSB7XG4gICAgdG91Y2ggPSB0b3VjaCB8fCBldnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJyAmJiBldnQ7XG5cbiAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8IHRvdWNoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRvdWNoKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgIG9uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAvLyBUaW1lb3V0IG5lY2Nlc3NhcnkgZm9yIElFOVxuICAgICAgICBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0sXG4gIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gX2RyYWdTdGFydGVkKGZhbGxiYWNrLCBldnQpIHtcblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb290RWwgJiYgZHJhZ0VsKSB7XG4gICAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0ZWQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gQXBwbHkgZWZmZWN0XG5cbiAgICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICBTb3J0YWJsZS5hY3RpdmUgPSB0aGlzO1xuICAgICAgZmFsbGJhY2sgJiYgdGhpcy5fYXBwZW5kR2hvc3QoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgfVxuICB9LFxuICBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiBfZW11bGF0ZURyYWdPdmVyKCkge1xuICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgdGhpcy5fbGFzdFggPSB0b3VjaEV2dC5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xuXG4gICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgdmFyIHBhcmVudCA9IHRhcmdldDtcblxuICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBwYXJlbnQpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwodGFyZ2V0KTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHBhcmVudFtleHBhbmRvXSkge1xuICAgICAgICAgICAgdmFyIGluc2VydGVkID0gdm9pZCAwO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBwYXJlbnRbZXhwYW5kb10uX29uRHJhZ092ZXIoe1xuICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaEV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIXRoaXMub3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQ7IC8vIHN0b3JlIGxhc3QgZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgfVxuICB9LFxuICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIF9vblRvdWNoTW92ZShcbiAgLyoqVG91Y2hFdmVudCovXG4gIGV2dCkge1xuICAgIGlmICh0YXBFdnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGZhbGxiYWNrVG9sZXJhbmNlID0gb3B0aW9ucy5mYWxsYmFja1RvbGVyYW5jZSxcbiAgICAgICAgICBmYWxsYmFja09mZnNldCA9IG9wdGlvbnMuZmFsbGJhY2tPZmZzZXQsXG4gICAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0LFxuICAgICAgICAgIGdob3N0TWF0cml4ID0gZ2hvc3RFbCAmJiBtYXRyaXgoZ2hvc3RFbCwgdHJ1ZSksXG4gICAgICAgICAgc2NhbGVYID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguZCxcbiAgICAgICAgICByZWxhdGl2ZVNjcm9sbE9mZnNldCA9IFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgJiYgZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCksXG4gICAgICAgICAgZHggPSAodG91Y2guY2xpZW50WCAtIHRhcEV2dC5jbGllbnRYICsgZmFsbGJhY2tPZmZzZXQueCkgLyAoc2NhbGVYIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMF0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFswXSA6IDApIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICBkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkgKyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdIDogMCkgLyAoc2NhbGVZIHx8IDEpOyAvLyBvbmx5IHNldCB0aGUgc3RhdHVzIHRvIGRyYWdnaW5nLCB3aGVuIHdlIGFyZSBhY3R1YWxseSBkcmFnZ2luZ1xuXG4gICAgICBpZiAoIVNvcnRhYmxlLmFjdGl2ZSAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICBpZiAoZmFsbGJhY2tUb2xlcmFuY2UgJiYgTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPCBmYWxsYmFja1RvbGVyYW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnaG9zdEVsKSB7XG4gICAgICAgIGlmIChnaG9zdE1hdHJpeCkge1xuICAgICAgICAgIGdob3N0TWF0cml4LmUgKz0gZHggLSAobGFzdER4IHx8IDApO1xuICAgICAgICAgIGdob3N0TWF0cml4LmYgKz0gZHkgLSAobGFzdER5IHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0TWF0cml4ID0ge1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgZDogMSxcbiAgICAgICAgICAgIGU6IGR4LFxuICAgICAgICAgICAgZjogZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc01hdHJpeCA9IFwibWF0cml4KFwiLmNvbmNhdChnaG9zdE1hdHJpeC5hLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmIsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYywgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5kLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmUsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZiwgXCIpXCIpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbW96VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtc1RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgbGFzdER4ID0gZHg7XG4gICAgICAgIGxhc3REeSA9IGR5O1xuICAgICAgICB0b3VjaEV2dCA9IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gX2FwcGVuZEdob3N0KCkge1xuICAgIC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XG4gICAgLy8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxuICAgIGlmICghZ2hvc3RFbCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5mYWxsYmFja09uQm9keSA/IGRvY3VtZW50LmJvZHkgOiByb290RWwsXG4gICAgICAgICAgcmVjdCA9IGdldFJlY3QoZHJhZ0VsLCB0cnVlLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSwgdHJ1ZSwgY29udGFpbmVyKSxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBQb3NpdGlvbiBhYnNvbHV0ZWx5XG5cbiAgICAgIGlmIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSkge1xuICAgICAgICAvLyBHZXQgcmVsYXRpdmVseSBwb3NpdGlvbmVkIHBhcmVudFxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdoaWxlIChjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnICYmIGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAndHJhbnNmb3JtJykgPT09ICdub25lJyAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCA9PT0gZG9jdW1lbnQpIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgcmVjdC50b3AgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcmVjdC5sZWZ0ICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgZ2hvc3RFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnYm94LXNpemluZycsICdib3JkZXItYm94Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ21hcmdpbicsIDApO1xuICAgICAgY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgICAgY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgICAgY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3Bvc2l0aW9uJywgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XG4gICAgICBTb3J0YWJsZS5naG9zdCA9IGdob3N0RWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2hvc3RFbCk7IC8vIFNldCB0cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtLW9yaWdpbicsIHRhcERpc3RhbmNlTGVmdCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUud2lkdGgpICogMTAwICsgJyUgJyArIHRhcERpc3RhbmNlVG9wIC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS5oZWlnaHQpICogMTAwICsgJyUnKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRyYWdTdGFydDogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KFxuICAvKipFdmVudCovXG4gIGV2dCxcbiAgLyoqYm9vbGVhbiovXG4gIGZhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldnQuZGF0YVRyYW5zZmVyO1xuICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0JywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbkV2ZW50KCdzZXR1cENsb25lJywgdGhpcyk7XG5cbiAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIGNsb25lRWwgPSBjbG9uZShkcmFnRWwpO1xuICAgICAgY2xvbmVFbC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIGNsb25lRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcblxuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIHRvZ2dsZUNsYXNzKGNsb25lRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuICAgICAgU29ydGFibGUuY2xvbmUgPSBjbG9uZUVsO1xuICAgIH0gLy8gIzExNDM6IElGcmFtZSBzdXBwb3J0IHdvcmthcm91bmRcblxuXG4gICAgX3RoaXMuY2xvbmVJZCA9IF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwbHVnaW5FdmVudCgnY2xvbmUnLCBfdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICBuYW1lOiAnY2xvbmUnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7IC8vIFNldCBwcm9wZXIgZHJvcCBldmVudHNcblxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gdHJ1ZTtcbiAgICAgIF90aGlzLl9sb29wSWQgPSBzZXRJbnRlcnZhbChfdGhpcy5fZW11bGF0ZURyYWdPdmVyLCA1MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuZG8gd2hhdCB3YXMgc2V0IGluIF9wcmVwYXJlRHJhZ1N0YXJ0IGJlZm9yZSBkcmFnIHN0YXJ0ZWRcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApO1xuXG4gICAgICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICBvcHRpb25zLnNldERhdGEgJiYgb3B0aW9ucy5zZXREYXRhLmNhbGwoX3RoaXMsIGRhdGFUcmFuc2ZlciwgZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgb24oZG9jdW1lbnQsICdkcm9wJywgX3RoaXMpOyAvLyAjMTI3NiBmaXg6XG5cbiAgICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xuICAgIH1cblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgIF90aGlzLl9kcmFnU3RhcnRJZCA9IF9uZXh0VGljayhfdGhpcy5fZHJhZ1N0YXJ0ZWQuYmluZChfdGhpcywgZmFsbGJhY2ssIGV2dCkpO1xuICAgIG9uKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCBfdGhpcyk7XG4gICAgbW92ZWQgPSB0cnVlO1xuXG4gICAgaWYgKFNhZmFyaSkge1xuICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICdub25lJyk7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm5zIHRydWUgLSBpZiBubyBmdXJ0aGVyIGFjdGlvbiBpcyBuZWVkZWQgKGVpdGhlciBpbnNlcnRlZCBvciBhbm90aGVyIGNvbmRpdGlvbilcbiAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uIF9vbkRyYWdPdmVyKFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgIGRyYWdSZWN0LFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICByZXZlcnQsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGdyb3VwID0gb3B0aW9ucy5ncm91cCxcbiAgICAgICAgYWN0aXZlU29ydGFibGUgPSBTb3J0YWJsZS5hY3RpdmUsXG4gICAgICAgIGlzT3duZXIgPSBhY3RpdmVHcm91cCA9PT0gZ3JvdXAsXG4gICAgICAgIGNhblNvcnQgPSBvcHRpb25zLnNvcnQsXG4gICAgICAgIGZyb21Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICB2ZXJ0aWNhbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjb21wbGV0ZWRGaXJlZCA9IGZhbHNlO1xuXG4gICAgaWYgKF9zaWxlbnQpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGRyYWdPdmVyRXZlbnQobmFtZSwgZXh0cmEpIHtcbiAgICAgIHBsdWdpbkV2ZW50KG5hbWUsIF90aGlzLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgIGlzT3duZXI6IGlzT3duZXIsXG4gICAgICAgIGF4aXM6IHZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgcmV2ZXJ0OiByZXZlcnQsXG4gICAgICAgIGRyYWdSZWN0OiBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdDogdGFyZ2V0UmVjdCxcbiAgICAgICAgY2FuU29ydDogY2FuU29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlOiBmcm9tU29ydGFibGUsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUodGFyZ2V0LCBhZnRlcikge1xuICAgICAgICAgIHJldHVybiBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgZ2V0UmVjdCh0YXJnZXQpLCBldnQsIGFmdGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlZDogY2hhbmdlZFxuICAgICAgfSwgZXh0cmEpKTtcbiAgICB9IC8vIENhcHR1cmUgYW5pbWF0aW9uIHN0YXRlXG5cblxuICAgIGZ1bmN0aW9uIGNhcHR1cmUoKSB7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUnKTtcblxuICAgICAgX3RoaXMuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgIGZyb21Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybiBpbnZvY2F0aW9uIHdoZW4gZHJhZ0VsIGlzIGluc2VydGVkIChvciBjb21wbGV0ZWQpXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZChpbnNlcnRpb24pIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQ29tcGxldGVkJywge1xuICAgICAgICBpbnNlcnRpb246IGluc2VydGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShfdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIC8vIFNldCBnaG9zdCBjbGFzcyB0byBuZXcgc29ydGFibGUncyBnaG9zdCBjbGFzc1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiBhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHV0U29ydGFibGUgIT09IF90aGlzICYmIF90aGlzICE9PSBTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF90aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzID09PSBTb3J0YWJsZS5hY3RpdmUgJiYgcHV0U29ydGFibGUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgIH0gLy8gQW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoZnJvbVNvcnRhYmxlID09PSBfdGhpcykge1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUnKTtcbiAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTnVsbCBsYXN0VGFyZ2V0IGlmIGl0IGlzIG5vdCBpbnNpZGUgYSBwcmV2aW91c2x5IHN3YXBwZWQgZWxlbWVudFxuXG5cbiAgICAgIGlmICh0YXJnZXQgPT09IGRyYWdFbCAmJiAhZHJhZ0VsLmFuaW1hdGVkIHx8IHRhcmdldCA9PT0gZWwgJiYgIXRhcmdldC5hbmltYXRlZCkge1xuICAgICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICAgIH0gLy8gbm8gYnViYmxpbmcgYW5kIG5vdCBmYWxsYmFja1xuXG5cbiAgICAgIGlmICghb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiAhZXZ0LnJvb3RFbCAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7IC8vIERvIG5vdCBkZXRlY3QgZm9yIGVtcHR5IGluc2VydCBpZiBhbHJlYWR5IGluc2VydGVkXG5cblxuICAgICAgICAhaW5zZXJ0aW9uICYmIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCk7XG4gICAgICB9XG5cbiAgICAgICFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZEZpcmVkID0gdHJ1ZTtcbiAgICB9IC8vIENhbGwgd2hlbiBkcmFnRWwgaGFzIGJlZW4gaW5zZXJ0ZWRcblxuXG4gICAgZnVuY3Rpb24gY2hhbmdlZCgpIHtcbiAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICBuYW1lOiAnY2hhbmdlJyxcbiAgICAgICAgdG9FbDogZWwsXG4gICAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChldnQucHJldmVudERlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgdHJ1ZSk7XG4gICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXInKTtcbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgaWYgKGRyYWdFbC5jb250YWlucyhldnQudGFyZ2V0KSB8fCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LmFuaW1hdGluZ1ggJiYgdGFyZ2V0LmFuaW1hdGluZ1kgfHwgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID09PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGl2ZVNvcnRhYmxlICYmICFvcHRpb25zLmRpc2FibGVkICYmIChpc093bmVyID8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gIXJvb3RFbC5jb250YWlucyhkcmFnRWwpKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgOiBwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fCAodGhpcy5sYXN0UHV0TW9kZSA9IGFjdGl2ZUdyb3VwLmNoZWNrUHVsbCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSAmJiBncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSkge1xuICAgICAgdmVydGljYWwgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpID09PSAndmVydGljYWwnO1xuICAgICAgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCk7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlclZhbGlkJyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAgIHBhcmVudEVsID0gcm9vdEVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ3JldmVydCcpO1xuXG4gICAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0RWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxMYXN0Q2hpbGQgPSBsYXN0Q2hpbGQoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgaWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XG4gICAgICAgIC8vIElmIGFscmVhZHkgYXQgZW5kIG9mIGxpc3Q6IERvIG5vdCBpbnNlcnRcbiAgICAgICAgaWYgKGVsTGFzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfSAvLyBhc3NpZ24gdGFyZ2V0IG9ubHkgaWYgY29uZGl0aW9uIGlzIHRydWVcblxuXG4gICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbCA9PT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGVsTGFzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgISF0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNhcHR1cmUoKTtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIHBhcmVudEVsID0gZWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gMCxcbiAgICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCxcbiAgICAgICAgICAgIGRpZmZlcmVudExldmVsID0gZHJhZ0VsLnBhcmVudE5vZGUgIT09IGVsLFxuICAgICAgICAgICAgZGlmZmVyZW50Um93Q29sID0gIV9kcmFnRWxJblJvd0NvbHVtbihkcmFnRWwuYW5pbWF0ZWQgJiYgZHJhZ0VsLnRvUmVjdCB8fCBkcmFnUmVjdCwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC50b1JlY3QgfHwgdGFyZ2V0UmVjdCwgdmVydGljYWwpLFxuICAgICAgICAgICAgc2lkZTEgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICAgICAgc2Nyb2xsZWRQYXN0VG9wID0gaXNTY3JvbGxlZFBhc3QodGFyZ2V0LCAndG9wJywgJ3RvcCcpIHx8IGlzU2Nyb2xsZWRQYXN0KGRyYWdFbCwgJ3RvcCcsICd0b3AnKSxcbiAgICAgICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbGVkUGFzdFRvcCA/IHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3AgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGxhc3RUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCA9IHRhcmdldFJlY3Rbc2lkZTFdO1xuICAgICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSAhZGlmZmVyZW50Um93Q29sICYmIG9wdGlvbnMuaW52ZXJ0U3dhcCB8fCBkaWZmZXJlbnRMZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpcmVjdGlvbiA9IF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgZGlmZmVyZW50Um93Q29sID8gMSA6IG9wdGlvbnMuc3dhcFRocmVzaG9sZCwgb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQgPT0gbnVsbCA/IG9wdGlvbnMuc3dhcFRocmVzaG9sZCA6IG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0LCBsYXN0VGFyZ2V0ID09PSB0YXJnZXQpO1xuICAgICAgICB2YXIgc2libGluZztcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGJlc2lkZSBkcmFnRWwgaW4gcmVzcGVjdGl2ZSBkaXJlY3Rpb24gKGlnbm9yaW5nIGhpZGRlbiBlbGVtZW50cylcbiAgICAgICAgICB2YXIgZHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRyYWdJbmRleCAtPSBkaXJlY3Rpb247XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50RWwuY2hpbGRyZW5bZHJhZ0luZGV4XTtcbiAgICAgICAgICB9IHdoaWxlIChzaWJsaW5nICYmIChjc3Moc2libGluZywgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNpYmxpbmcgPT09IGdob3N0RWwpKTtcbiAgICAgICAgfSAvLyBJZiBkcmFnRWwgaXMgYWxyZWFkeSBiZXNpZGUgdGFyZ2V0OiBEbyBub3QgaW5zZXJ0XG5cblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIHx8IHNpYmxpbmcgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgIGFmdGVyID0gZmFsc2U7XG4gICAgICAgIGFmdGVyID0gZGlyZWN0aW9uID09PSAxO1xuXG4gICAgICAgIHZhciBtb3ZlVmVjdG9yID0gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgYWZ0ZXIpO1xuXG4gICAgICAgIGlmIChtb3ZlVmVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XG4gICAgICAgICAgICBhZnRlciA9IG1vdmVWZWN0b3IgPT09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3NpbGVudCA9IHRydWU7XG4gICAgICAgICAgc2V0VGltZW91dChfdW5zaWxlbnQsIDMwKTtcbiAgICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBhZnRlciA/IG5leHRTaWJsaW5nIDogdGFyZ2V0KTtcbiAgICAgICAgICB9IC8vIFVuZG8gY2hyb21lJ3Mgc2Nyb2xsIGFkanVzdG1lbnQgKGhhcyBubyBlZmZlY3Qgb24gb3RoZXIgYnJvd3NlcnMpXG5cblxuICAgICAgICAgIGlmIChzY3JvbGxlZFBhc3RUb3ApIHtcbiAgICAgICAgICAgIHNjcm9sbEJ5KHNjcm9sbGVkUGFzdFRvcCwgMCwgc2Nyb2xsQmVmb3JlIC0gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxuICAgICAgICAgIC8vIG11c3QgYmUgZG9uZSBiZWZvcmUgYW5pbWF0aW9uXG5cbiAgICAgICAgICBpZiAodGFyZ2V0QmVmb3JlRmlyc3RTd2FwICE9PSB1bmRlZmluZWQgJiYgIWlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQpIHtcbiAgICAgICAgICAgIHRhcmdldE1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAtIGdldFJlY3QodGFyZ2V0KVtzaWRlMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5jb250YWlucyhkcmFnRWwpKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgX2lnbm9yZVdoaWxlQW5pbWF0aW5nOiBudWxsLFxuICBfb2ZmTW92ZUV2ZW50czogZnVuY3Rpb24gX29mZk1vdmVFdmVudHMoKSB7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICB9LFxuICBfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uIF9vZmZVcEV2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYoZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9LFxuICBfb25Ecm9wOiBmdW5jdGlvbiBfb25Ecm9wKFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG4gICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgcGx1Z2luRXZlbnQoJ2Ryb3AnLCB0aGlzLCB7XG4gICAgICBldnQ6IGV2dFxuICAgIH0pO1xuICAgIHBhcmVudEVsID0gZHJhZ0VsICYmIGRyYWdFbC5wYXJlbnROb2RlOyAvLyBHZXQgYWdhaW4gYWZ0ZXIgcGx1Z2luIGV2ZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlO1xuICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuY2xvbmVJZCk7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5fZHJhZ1N0YXJ0SWQpOyAvLyBVbmJpbmQgZXZlbnRzXG5cblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGRvY3VtZW50LCAnZHJvcCcsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cblxuICAgIHRoaXMuX29mZk1vdmVFdmVudHMoKTtcblxuICAgIHRoaXMuX29mZlVwRXZlbnRzKCk7XG5cbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJycpO1xuICAgIH1cblxuICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICBpZiAoZXZ0KSB7XG4gICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICFvcHRpb25zLmRyb3BCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZSAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XG5cbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjbG9uZShzKVxuICAgICAgICBjbG9uZUVsICYmIGNsb25lRWwucGFyZW50Tm9kZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgb2ZmKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG5cbiAgICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7IC8vIFJlbW92ZSBjbGFzc2VzXG4gICAgICAgIC8vIGdob3N0Q2xhc3MgaXMgYWRkZWQgaW4gZHJhZ1N0YXJ0ZWRcblxuICAgICAgICBpZiAobW92ZWQgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7IC8vIERyYWcgc3RvcCBldmVudFxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICBuYW1lOiAndW5jaG9vc2UnLFxuICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgIG5ld0luZGV4OiBudWxsLFxuICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBudWxsLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocm9vdEVsICE9PSBwYXJlbnRFbCkge1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnRcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ2FkZCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gUmVtb3ZlIGV2ZW50XG5cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBkcmFnIGZyb20gb25lIGxpc3QgYW5kIGRyb3AgaW50byBhbm90aGVyXG5cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5zYXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ICE9PSBvbGRJbmRleCkge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgLy8gZHJhZyAmIGRyb3Agd2l0aGluIHRoZSBzYW1lIGxpc3RcbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgLyoganNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgaWYgKG5ld0luZGV4ID09IG51bGwgfHwgbmV3SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IG9sZEluZGV4O1xuICAgICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgIG5hbWU6ICdlbmQnLFxuICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTsgLy8gU2F2ZSBzb3J0aW5nXG5cblxuICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbnVsbGluZygpO1xuICB9LFxuICBfbnVsbGluZzogZnVuY3Rpb24gX251bGxpbmcoKSB7XG4gICAgcGx1Z2luRXZlbnQoJ251bGxpbmcnLCB0aGlzKTtcbiAgICByb290RWwgPSBkcmFnRWwgPSBwYXJlbnRFbCA9IGdob3N0RWwgPSBuZXh0RWwgPSBjbG9uZUVsID0gbGFzdERvd25FbCA9IGNsb25lSGlkZGVuID0gdGFwRXZ0ID0gdG91Y2hFdnQgPSBtb3ZlZCA9IG5ld0luZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4ID0gbGFzdFRhcmdldCA9IGxhc3REaXJlY3Rpb24gPSBwdXRTb3J0YWJsZSA9IGFjdGl2ZUdyb3VwID0gU29ydGFibGUuZHJhZ2dlZCA9IFNvcnRhYmxlLmdob3N0ID0gU29ydGFibGUuY2xvbmUgPSBTb3J0YWJsZS5hY3RpdmUgPSBudWxsO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5jaGVja2VkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSBsYXN0RHggPSBsYXN0RHkgPSAwO1xuICB9LFxuICBoYW5kbGVFdmVudDogZnVuY3Rpb24gaGFuZGxlRXZlbnQoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgY2FzZSAnZHJvcCc6XG4gICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgdGhpcy5fb25Ecm9wKGV2dCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgICBjYXNlICdkcmFnb3Zlcic6XG4gICAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgICB0aGlzLl9vbkRyYWdPdmVyKGV2dCk7XG5cbiAgICAgICAgICBfZ2xvYmFsRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzZWxlY3RzdGFydCc6XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGl0ZW0gaW50byBhbiBhcnJheSBvZiBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIG9yZGVyID0gW10sXG4gICAgICAgIGVsLFxuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZWwuY2hpbGRyZW4sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGVsID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjbG9zZXN0KGVsLCBvcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpKSB7XG4gICAgICAgIG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGFycmF5LlxuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gIG9yZGVyICBvcmRlciBvZiB0aGUgaXRlbXNcbiAgICovXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQob3JkZXIpIHtcbiAgICB2YXIgaXRlbXMgPSB7fSxcbiAgICAgICAgcm9vdEVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgdmFyIGVsID0gcm9vdEVsLmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsLCBmYWxzZSkpIHtcbiAgICAgICAgaXRlbXNbaWRdID0gZWw7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChpdGVtc1tpZF0pIHtcbiAgICAgICAgcm9vdEVsLnJlbW92ZUNoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSBjdXJyZW50IHNvcnRpbmdcbiAgICovXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5vcHRpb25zLnN0b3JlO1xuICAgIHN0b3JlICYmIHN0b3JlLnNldCAmJiBzdG9yZS5zZXQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgZ2V0IHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IgYnkgdGVzdGluZyB0aGUgZWxlbWVudCBpdHNlbGYgYW5kIHRyYXZlcnNpbmcgdXAgdGhyb3VnaCBpdHMgYW5jZXN0b3JzIGluIHRoZSBET00gdHJlZS5cbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgZWxcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QkMShlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gY2xvc2VzdChlbCwgc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQvZ2V0IG9wdGlvblxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSAgIHsqfSAgICAgIFt2YWx1ZV1cbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBvcHRpb246IGZ1bmN0aW9uIG9wdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBvcHRpb25zW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IFBsdWdpbk1hbmFnZXIubW9kaWZ5T3B0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gbW9kaWZpZWRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdncm91cCcpIHtcbiAgICAgICAgX3ByZXBhcmVHcm91cChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgcGx1Z2luRXZlbnQoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICBvZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgIG9mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICAgIH0gLy8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXG5cblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgIHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xuICAgIHRoaXMuZWwgPSBlbCA9IG51bGw7XG4gIH0sXG4gIF9oaWRlQ2xvbmU6IGZ1bmN0aW9uIF9oaWRlQ2xvbmUoKSB7XG4gICAgaWYgKCFjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ2hpZGVDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgX3Nob3dDbG9uZTogZnVuY3Rpb24gX3Nob3dDbG9uZShwdXRTb3J0YWJsZSkge1xuICAgIGlmIChwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdzaG93Q2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47IC8vIHNob3cgY2xvbmUgYXQgZHJhZ0VsIG9yIG9yaWdpbmFsIHBvc2l0aW9uXG5cbiAgICAgIGlmIChyb290RWwuY29udGFpbnMoZHJhZ0VsKSAmJiAhdGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dEVsKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGUoZHJhZ0VsLCBjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9nbG9iYWxEcmFnT3Zlcihcbi8qKkV2ZW50Ki9cbmV2dCkge1xuICBpZiAoZXZ0LmRhdGFUcmFuc2Zlcikge1xuICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxuXG4gIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBfb25Nb3ZlKGZyb21FbCwgdG9FbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0RWwsIHRhcmdldFJlY3QsIG9yaWdpbmFsRXZlbnQsIHdpbGxJbnNlcnRBZnRlcikge1xuICB2YXIgZXZ0LFxuICAgICAgc29ydGFibGUgPSBmcm9tRWxbZXhwYW5kb10sXG4gICAgICBvbk1vdmVGbiA9IHNvcnRhYmxlLm9wdGlvbnMub25Nb3ZlLFxuICAgICAgcmV0VmFsOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vdmUnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsO1xuICBldnQuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgZXZ0LmRyYWdnZWRSZWN0ID0gZHJhZ1JlY3Q7XG4gIGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcbiAgZXZ0LnJlbGF0ZWRSZWN0ID0gdGFyZ2V0UmVjdCB8fCBnZXRSZWN0KHRvRWwpO1xuICBldnQud2lsbEluc2VydEFmdGVyID0gd2lsbEluc2VydEFmdGVyO1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGZyb21FbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgaWYgKG9uTW92ZUZuKSB7XG4gICAgcmV0VmFsID0gb25Nb3ZlRm4uY2FsbChzb3J0YWJsZSwgZXZ0LCBvcmlnaW5hbEV2ZW50KTtcbiAgfVxuXG4gIHJldHVybiByZXRWYWw7XG59XG5cbmZ1bmN0aW9uIF9kaXNhYmxlRHJhZ2dhYmxlKGVsKSB7XG4gIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdW5zaWxlbnQoKSB7XG4gIF9zaWxlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gIHZhciByZWN0ID0gZ2V0UmVjdChsYXN0Q2hpbGQoc29ydGFibGUuZWwsIHNvcnRhYmxlLm9wdGlvbnMuZHJhZ2dhYmxlKSk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICsgc3BhY2VyIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSAmJiBldnQuY2xpZW50WCA+PSByZWN0LmxlZnQgOiBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LnRvcCB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gKyBzcGFjZXI7XG59XG5cbmZ1bmN0aW9uIF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgc3dhcFRocmVzaG9sZCwgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpbnZlcnRTd2FwLCBpc0xhc3RUYXJnZXQpIHtcbiAgdmFyIG1vdXNlT25BeGlzID0gdmVydGljYWwgPyBldnQuY2xpZW50WSA6IGV2dC5jbGllbnRYLFxuICAgICAgdGFyZ2V0TGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmhlaWdodCA6IHRhcmdldFJlY3Qud2lkdGgsXG4gICAgICB0YXJnZXRTMSA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC50b3AgOiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICB0YXJnZXRTMiA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5ib3R0b20gOiB0YXJnZXRSZWN0LnJpZ2h0LFxuICAgICAgaW52ZXJ0ID0gZmFsc2U7XG5cbiAgaWYgKCFpbnZlcnRTd2FwKSB7XG4gICAgLy8gTmV2ZXIgaW52ZXJ0IG9yIGNyZWF0ZSBkcmFnRWwgc2hhZG93IHdoZW4gdGFyZ2V0IG1vdmVtZW5ldCBjYXVzZXMgbW91c2UgdG8gbW92ZSBwYXN0IHRoZSBlbmQgb2YgcmVndWxhciBzd2FwVGhyZXNob2xkXG4gICAgaWYgKGlzTGFzdFRhcmdldCAmJiB0YXJnZXRNb3ZlRGlzdGFuY2UgPCB0YXJnZXRMZW5ndGggKiBzd2FwVGhyZXNob2xkKSB7XG4gICAgICAvLyBtdWx0aXBsaWVkIG9ubHkgYnkgc3dhcFRocmVzaG9sZCBiZWNhdXNlIG1vdXNlIHdpbGwgYWxyZWFkeSBiZSBpbnNpZGUgdGFyZ2V0IGJ5ICgxIC0gdGhyZXNob2xkKSAqIHRhcmdldExlbmd0aCAvIDJcbiAgICAgIC8vIGNoZWNrIGlmIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCBvbiBzaWRlIG9wcG9zaXRlIG9mIGxhc3REaXJlY3Rpb25cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoICYmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgOiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikpIHtcbiAgICAgICAgLy8gcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkLCBkbyBub3QgcmVzdHJpY3QgaW52ZXJ0ZWQgdGhyZXNob2xkIHRvIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2gpIHtcbiAgICAgICAgLy8gZHJhZ0VsIHNoYWRvdyAodGFyZ2V0IG1vdmUgZGlzdGFuY2Ugc2hhZG93KVxuICAgICAgICBpZiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRNb3ZlRGlzdGFuY2UgLy8gb3ZlciBkcmFnRWwgc2hhZG93XG4gICAgICAgIDogbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldE1vdmVEaXN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiAtbGFzdERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52ZXJ0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVndWxhclxuICAgICAgaWYgKG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMiAmJiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnZlcnQgPSBpbnZlcnQgfHwgaW52ZXJ0U3dhcDtcblxuICBpZiAoaW52ZXJ0KSB7XG4gICAgLy8gSW52ZXJ0IG9mIHJlZ3VsYXJcbiAgICBpZiAobW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgfHwgbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpIHtcbiAgICAgIHJldHVybiBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cbi8qKlxuICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcbiAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXCJpbnNlcnRlZFwiIGludG8gdGhhdCBlbGVtZW50J3MgcG9zaXRpb25cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICAgICAgVGhlIHRhcmdldCB3aG9zZSBwb3NpdGlvbiBkcmFnRWwgaXMgYmVpbmcgaW5zZXJ0ZWQgYXRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KSB7XG4gIGlmIChpbmRleChkcmFnRWwpIDwgaW5kZXgodGFyZ2V0KSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuLyoqXG4gKiBHZW5lcmF0ZSBpZFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgc3VtID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIHN1bS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeC0tKSB7XG4gICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbmV4dFRpY2soZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59IC8vIEZpeGVkICM5NzM6XG5cblxuaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmICgoU29ydGFibGUuYWN0aXZlIHx8IGF3YWl0aW5nRHJhZ1N0YXJ0ZWQpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufSAvLyBFeHBvcnQgdXRpbHNcblxuXG5Tb3J0YWJsZS51dGlscyA9IHtcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgY3NzOiBjc3MsXG4gIGZpbmQ6IGZpbmQsXG4gIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgfSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgY2xvc2VzdDogY2xvc2VzdCxcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICBjbG9uZTogY2xvbmUsXG4gIGluZGV4OiBpbmRleCxcbiAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICBnZXRDaGlsZDogZ2V0Q2hpbGRcbn07XG4vKipcbiAqIEdldCB0aGUgU29ydGFibGUgaW5zdGFuY2Ugb2YgYW4gZWxlbWVudFxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcbiAqL1xuXG5Tb3J0YWJsZS5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudFtleHBhbmRvXTtcbn07XG4vKipcbiAqIE1vdW50IGEgcGx1Z2luIHRvIFNvcnRhYmxlXG4gKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxuICovXG5cblxuU29ydGFibGUubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocGx1Z2luc1swXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGlmICghcGx1Z2luLnByb3RvdHlwZSB8fCAhcGx1Z2luLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgXCJTb3J0YWJsZTogTW91bnRlZCBwbHVnaW4gbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwocGx1Z2luKSk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbi51dGlscykgU29ydGFibGUudXRpbHMgPSBfb2JqZWN0U3ByZWFkKHt9LCBTb3J0YWJsZS51dGlscywgcGx1Z2luLnV0aWxzKTtcbiAgICBQbHVnaW5NYW5hZ2VyLm1vdW50KHBsdWdpbik7XG4gIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRpb25zXVxuICovXG5cblxuU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xufTsgLy8gRXhwb3J0XG5cblxuU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgIHNjcm9sbEVsLFxuICAgIHNjcm9sbFJvb3RFbCxcbiAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgIHRvdWNoRXZ0JDEsXG4gICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgIGlmIChmYWxsYmFjayB8fCBFZGdlIHx8IElFMTFPckxlc3MgfHwgU2FmYXJpKSB7XG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGVsZW0sIGZhbGxiYWNrKTsgLy8gTGlzdGVuZXIgZm9yIHBvaW50ZXIgZWxlbWVudCBjaGFuZ2VcblxuICAgICAgICB2YXIgb2dFbGVtU2Nyb2xsZXIgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKTtcblxuICAgICAgICBpZiAoc2Nyb2xsaW5nICYmICghcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgfHwgeCAhPT0gbGFzdEF1dG9TY3JvbGxYIHx8IHkgIT09IGxhc3RBdXRvU2Nyb2xsWSkpIHtcbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCAmJiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7IC8vIERldGVjdCBmb3IgcG9pbnRlciBlbGVtIGNoYW5nZSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG5cbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbGVtID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdFbGVtICE9PSBvZ0VsZW1TY3JvbGxlcikge1xuICAgICAgICAgICAgICBvZ0VsZW1TY3JvbGxlciA9IG5ld0VsZW07XG4gICAgICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXV0b1Njcm9sbChldnQsIF90aGlzLm9wdGlvbnMsIG5ld0VsZW0sIGZhbGxiYWNrKTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxYID0geDtcbiAgICAgICAgICBsYXN0QXV0b1Njcm9sbFkgPSB5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBEbkQgaXMgZW5hYmxlZCAoYW5kIGJyb3dzZXIgaGFzIGdvb2QgYXV0b3Njcm9sbGluZyksIGZpcnN0IGF1dG9zY3JvbGwgd2lsbCBhbHJlYWR5IHNjcm9sbCwgc28gZ2V0IHBhcmVudCBhdXRvc2Nyb2xsIG9mIGZpcnN0IGF1dG9zY3JvbGxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYnViYmxlU2Nyb2xsIHx8IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgZmFsc2UpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoQXV0b1Njcm9sbCwge1xuICAgIHBsdWdpbk5hbWU6ICdzY3JvbGwnLFxuICAgIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQXV0b1Njcm9sbHMoKSB7XG4gIGF1dG9TY3JvbGxzLmZvckVhY2goZnVuY3Rpb24gKGF1dG9TY3JvbGwpIHtcbiAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGwucGlkKTtcbiAgfSk7XG4gIGF1dG9TY3JvbGxzID0gW107XG59XG5cbmZ1bmN0aW9uIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKSB7XG4gIGNsZWFySW50ZXJ2YWwocG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwpO1xufVxuXG52YXIgYXV0b1Njcm9sbCA9IHRocm90dGxlKGZ1bmN0aW9uIChldnQsIG9wdGlvbnMsIHJvb3RFbCwgaXNGYWxsYmFjaykge1xuICAvLyBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUwNTUyMVxuICBpZiAoIW9wdGlvbnMuc2Nyb2xsKSByZXR1cm47XG4gIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICBzZW5zID0gb3B0aW9ucy5zY3JvbGxTZW5zaXRpdml0eSxcbiAgICAgIHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcbiAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgc2Nyb2xsVGhpc0luc3RhbmNlID0gZmFsc2UsXG4gICAgICBzY3JvbGxDdXN0b21GbjsgLy8gTmV3IHNjcm9sbCByb290LCBzZXQgc2Nyb2xsRWxcblxuICBpZiAoc2Nyb2xsUm9vdEVsICE9PSByb290RWwpIHtcbiAgICBzY3JvbGxSb290RWwgPSByb290RWw7XG4gICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgIHNjcm9sbEVsID0gb3B0aW9ucy5zY3JvbGw7XG4gICAgc2Nyb2xsQ3VzdG9tRm4gPSBvcHRpb25zLnNjcm9sbEZuO1xuXG4gICAgaWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XG4gICAgICBzY3JvbGxFbCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHJvb3RFbCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxheWVyc091dCA9IDA7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gc2Nyb2xsRWw7XG5cbiAgZG8ge1xuICAgIHZhciBlbCA9IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIHJlY3QgPSBnZXRSZWN0KGVsKSxcbiAgICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tLFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICByaWdodCA9IHJlY3QucmlnaHQsXG4gICAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICAgIGNhblNjcm9sbFggPSB2b2lkIDAsXG4gICAgICAgIGNhblNjcm9sbFkgPSB2b2lkIDAsXG4gICAgICAgIHNjcm9sbFdpZHRoID0gZWwuc2Nyb2xsV2lkdGgsXG4gICAgICAgIHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCxcbiAgICAgICAgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgICBzY3JvbGxQb3NYID0gZWwuc2Nyb2xsTGVmdCxcbiAgICAgICAgc2Nyb2xsUG9zWSA9IGVsLnNjcm9sbFRvcDtcblxuICAgIGlmIChlbCA9PT0gd2luU2Nyb2xsZXIpIHtcbiAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Zpc2libGUnKTtcbiAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAndmlzaWJsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnKTtcbiAgICB9XG5cbiAgICB2YXIgdnggPSBjYW5TY3JvbGxYICYmIChNYXRoLmFicyhyaWdodCAtIHgpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWCArIHdpZHRoIDwgc2Nyb2xsV2lkdGgpIC0gKE1hdGguYWJzKGxlZnQgLSB4KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWCk7XG4gICAgdmFyIHZ5ID0gY2FuU2Nyb2xsWSAmJiAoTWF0aC5hYnMoYm90dG9tIC0geSkgPD0gc2VucyAmJiBzY3JvbGxQb3NZICsgaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0KSAtIChNYXRoLmFicyh0b3AgLSB5KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWSk7XG5cbiAgICBpZiAoIWF1dG9TY3JvbGxzW2xheWVyc091dF0pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxheWVyc091dDsgaSsrKSB7XG4gICAgICAgIGlmICghYXV0b1Njcm9sbHNbaV0pIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsc1tpXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggIT0gdnggfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSAhPSB2eSB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsICE9PSBlbCkge1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCA9IGVsO1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCA9IHZ4O1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSA9IHZ5O1xuICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCk7XG5cbiAgICAgIGlmICh2eCAhPSAwIHx8IHZ5ICE9IDApIHtcbiAgICAgICAgc2Nyb2xsVGhpc0luc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cblxuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBlbXVsYXRlIGRyYWcgb3ZlciBkdXJpbmcgYXV0b3Njcm9sbCAoZmFsbGJhY2spLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcbiAgICAgICAgICBpZiAoaXNGYWxsYmFjayAmJiB0aGlzLmxheWVyID09PSAwKSB7XG4gICAgICAgICAgICBTb3J0YWJsZS5hY3RpdmUuX29uVG91Y2hNb3ZlKHRvdWNoRXZ0JDEpOyAvLyBUbyBtb3ZlIGdob3N0IGlmIGl0IGlzIHBvc2l0aW9uZWQgYWJzb2x1dGVseVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFkgPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ICogc3BlZWQgOiAwO1xuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRYID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCAqIHNwZWVkIDogMDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsQ3VzdG9tRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxDdXN0b21Gbi5jYWxsKFNvcnRhYmxlLmRyYWdnZWQucGFyZW50Tm9kZVtleHBhbmRvXSwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgZXZ0LCB0b3VjaEV2dCQxLCBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCkgIT09ICdjb250aW51ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjcm9sbEJ5KGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZKTtcbiAgICAgICAgfS5iaW5kKHtcbiAgICAgICAgICBsYXllcjogbGF5ZXJzT3V0XG4gICAgICAgIH0pLCAyNCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGF5ZXJzT3V0Kys7XG4gIH0gd2hpbGUgKG9wdGlvbnMuYnViYmxlU2Nyb2xsICYmIGN1cnJlbnRQYXJlbnQgIT09IHdpblNjcm9sbGVyICYmIChjdXJyZW50UGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoY3VycmVudFBhcmVudCwgZmFsc2UpKSk7XG5cbiAgc2Nyb2xsaW5nID0gc2Nyb2xsVGhpc0luc3RhbmNlOyAvLyBpbiBjYXNlIGFub3RoZXIgZnVuY3Rpb24gY2F0Y2hlcyBzY3JvbGxpbmcgYXMgZmFsc2UgaW4gYmV0d2VlbiB3aGVuIGl0IGlzIG5vdFxufSwgMzApO1xuXG52YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoX3JlZikge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICAgIHB1dFNvcnRhYmxlID0gX3JlZi5wdXRTb3J0YWJsZSxcbiAgICAgIGRyYWdFbCA9IF9yZWYuZHJhZ0VsLFxuICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICBoaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi51bmhpZGVHaG9zdEZvclRhcmdldDtcbiAgaWYgKCFvcmlnaW5hbEV2ZW50KSByZXR1cm47XG4gIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGU7XG4gIGhpZGVHaG9zdEZvclRhcmdldCgpO1xuICB2YXIgdG91Y2ggPSBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID8gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IG9yaWdpbmFsRXZlbnQ7XG4gIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICB1bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gIGlmICh0b1NvcnRhYmxlICYmICF0b1NvcnRhYmxlLmVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3NwaWxsJyk7XG4gICAgdGhpcy5vblNwaWxsKHtcbiAgICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlXG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJldmVydCgpIHt9XG5cblJldmVydC5wcm90b3R5cGUgPSB7XG4gIHN0YXJ0SW5kZXg6IG51bGwsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgdmFyIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZjIub2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIH0sXG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjMpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlO1xuICAgIHRoaXMuc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBuZXh0U2libGluZyA9IGdldENoaWxkKHRoaXMuc29ydGFibGUuZWwsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgdGhpcy5zb3J0YWJsZS5lbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcblxuICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgcHV0U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgIH1cbiAgfSxcbiAgZHJvcDogZHJvcFxufTtcblxuX2V4dGVuZHMoUmV2ZXJ0LCB7XG4gIHBsdWdpbk5hbWU6ICdyZXZlcnRPblNwaWxsJ1xufSk7XG5cbmZ1bmN0aW9uIFJlbW92ZSgpIHt9XG5cblJlbW92ZS5wcm90b3R5cGUgPSB7XG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjQpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjQuZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWY0LnB1dFNvcnRhYmxlO1xuICAgIHZhciBwYXJlbnRTb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgcGFyZW50U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGUgJiYgZHJhZ0VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtcbiAgICBwYXJlbnRTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJlbW92ZSwge1xuICBwbHVnaW5OYW1lOiAncmVtb3ZlT25TcGlsbCdcbn0pO1xuXG52YXIgbGFzdFN3YXBFbDtcblxuZnVuY3Rpb24gU3dhcFBsdWdpbigpIHtcbiAgZnVuY3Rpb24gU3dhcCgpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc3dhcENsYXNzOiAnc29ydGFibGUtc3dhcC1oaWdobGlnaHQnXG4gICAgfTtcbiAgfVxuXG4gIFN3YXAucHJvdG90eXBlID0ge1xuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYpIHtcbiAgICAgIHZhciBkcmFnRWwgPSBfcmVmLmRyYWdFbDtcbiAgICAgIGxhc3RTd2FwRWwgPSBkcmFnRWw7XG4gICAgfSxcbiAgICBkcmFnT3ZlclZhbGlkOiBmdW5jdGlvbiBkcmFnT3ZlclZhbGlkKF9yZWYyKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gX3JlZjIuY29tcGxldGVkLFxuICAgICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgICBvbk1vdmUgPSBfcmVmMi5vbk1vdmUsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBjaGFuZ2VkID0gX3JlZjIuY2hhbmdlZCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc3dhcCkgcmV0dXJuO1xuICAgICAgdmFyIGVsID0gdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgdmFyIHByZXZTd2FwRWwgPSBsYXN0U3dhcEVsO1xuXG4gICAgICAgIGlmIChvbk1vdmUodGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIG9wdGlvbnMuc3dhcENsYXNzLCB0cnVlKTtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gdGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTd2FwRWwgJiYgcHJldlN3YXBFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHByZXZTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hhbmdlZCgpO1xuICAgICAgY29tcGxldGVkKHRydWUpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYzKSB7XG4gICAgICB2YXIgYWN0aXZlU29ydGFibGUgPSBfcmVmMy5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlLFxuICAgICAgICAgIGRyYWdFbCA9IF9yZWYzLmRyYWdFbDtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgbGFzdFN3YXBFbCAmJiB0b2dnbGVDbGFzcyhsYXN0U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuXG4gICAgICBpZiAobGFzdFN3YXBFbCAmJiAob3B0aW9ucy5zd2FwIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLm9wdGlvbnMuc3dhcCkpIHtcbiAgICAgICAgaWYgKGRyYWdFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBzd2FwTm9kZXMoZHJhZ0VsLCBsYXN0U3dhcEVsKTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKFN3YXAsIHtcbiAgICBwbHVnaW5OYW1lOiAnc3dhcCcsXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzd2FwSXRlbTogbGFzdFN3YXBFbFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzd2FwTm9kZXMobjEsIG4yKSB7XG4gIHZhciBwMSA9IG4xLnBhcmVudE5vZGUsXG4gICAgICBwMiA9IG4yLnBhcmVudE5vZGUsXG4gICAgICBpMSxcbiAgICAgIGkyO1xuICBpZiAoIXAxIHx8ICFwMiB8fCBwMS5pc0VxdWFsTm9kZShuMikgfHwgcDIuaXNFcXVhbE5vZGUobjEpKSByZXR1cm47XG4gIGkxID0gaW5kZXgobjEpO1xuICBpMiA9IGluZGV4KG4yKTtcblxuICBpZiAocDEuaXNFcXVhbE5vZGUocDIpICYmIGkxIDwgaTIpIHtcbiAgICBpMisrO1xuICB9XG5cbiAgcDEuaW5zZXJ0QmVmb3JlKG4yLCBwMS5jaGlsZHJlbltpMV0pO1xuICBwMi5pbnNlcnRCZWZvcmUobjEsIHAyLmNoaWxkcmVuW2kyXSk7XG59XG5cbnZhciBtdWx0aURyYWdFbGVtZW50cyA9IFtdLFxuICAgIG11bHRpRHJhZ0Nsb25lcyA9IFtdLFxuICAgIGxhc3RNdWx0aURyYWdTZWxlY3QsXG4gICAgLy8gZm9yIHNlbGVjdGlvbiB3aXRoIG1vZGlmaWVyIGtleSBkb3duIChTSElGVClcbm11bHRpRHJhZ1NvcnRhYmxlLFxuICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2UsXG4gICAgLy8gSW5pdGlhbCBtdWx0aS1kcmFnIGZvbGQgd2hlbiBkcmFnIHN0YXJ0ZWRcbmZvbGRpbmcgPSBmYWxzZSxcbiAgICAvLyBGb2xkaW5nIGFueSBvdGhlciB0aW1lXG5kcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGRyYWdFbCQxLFxuICAgIGNsb25lc0Zyb21SZWN0LFxuICAgIGNsb25lc0hpZGRlbjtcblxuZnVuY3Rpb24gTXVsdGlEcmFnUGx1Z2luKCkge1xuICBmdW5jdGlvbiBNdWx0aURyYWcoc29ydGFibGUpIHtcbiAgICAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc29ydGFibGUub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgfVxuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICBvbihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNlbGVjdGVkQ2xhc3M6ICdzb3J0YWJsZS1zZWxlY3RlZCcsXG4gICAgICBtdWx0aURyYWdLZXk6IG51bGwsXG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICAgIHZhciBkYXRhID0gJyc7XG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBkYXRhICs9ICghaSA/ICcnIDogJywgJykgKyBtdWx0aURyYWdFbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBkcmFnRWwudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBNdWx0aURyYWcucHJvdG90eXBlID0ge1xuICAgIG11bHRpRHJhZ0tleURvd246IGZhbHNlLFxuICAgIGlzTXVsdGlEcmFnOiBmYWxzZSxcbiAgICBkZWxheVN0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkZWxheVN0YXJ0R2xvYmFsKF9yZWYpIHtcbiAgICAgIHZhciBkcmFnZ2VkID0gX3JlZi5kcmFnRWw7XG4gICAgICBkcmFnRWwkMSA9IGRyYWdnZWQ7XG4gICAgfSxcbiAgICBkZWxheUVuZGVkOiBmdW5jdGlvbiBkZWxheUVuZGVkKCkge1xuICAgICAgdGhpcy5pc011bHRpRHJhZyA9IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKTtcbiAgICB9LFxuICAgIHNldHVwQ2xvbmU6IGZ1bmN0aW9uIHNldHVwQ2xvbmUoX3JlZjIpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYyLnNvcnRhYmxlLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5wdXNoKGNsb25lKG11bHRpRHJhZ0VsZW1lbnRzW2ldKSk7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zb3J0YWJsZUluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHNbaV0uc29ydGFibGVJbmRleDtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcbiAgICAgICAgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50c1tpXSA9PT0gZHJhZ0VsJDEgJiYgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc29ydGFibGUuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShfcmVmMykge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjMuc29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjMucm9vdEVsLFxuICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYzLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMy5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBpbnNlcnRNdWx0aURyYWdDbG9uZXModHJ1ZSwgcm9vdEVsKTtcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ2Nsb25lJyk7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dDbG9uZTogZnVuY3Rpb24gc2hvd0Nsb25lKF9yZWY0KSB7XG4gICAgICB2YXIgY2xvbmVOb3dTaG93biA9IF9yZWY0LmNsb25lTm93U2hvd24sXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjQucm9vdEVsLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY0LmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGZhbHNlLCByb290RWwpO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93U2hvd24oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBoaWRlQ2xvbmU6IGZ1bmN0aW9uIGhpZGVDbG9uZShfcmVmNSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjUuc29ydGFibGUsXG4gICAgICAgICAgY2xvbmVOb3dIaWRkZW4gPSBfcmVmNS5jbG9uZU5vd0hpZGRlbixcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmNS5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xvbmVOb3dIaWRkZW4oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IHRydWU7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGRyYWdTdGFydEdsb2JhbDogZnVuY3Rpb24gZHJhZ1N0YXJ0R2xvYmFsKF9yZWY2KSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNi5zb3J0YWJsZTtcblxuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnICYmIG11bHRpRHJhZ1NvcnRhYmxlKSB7XG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgIH1cblxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgIH0pOyAvLyBTb3J0IG11bHRpLWRyYWcgZWxlbWVudHNcblxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMgPSBtdWx0aURyYWdFbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnNvcnRhYmxlSW5kZXggLSBiLnNvcnRhYmxlSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmNykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY3LnNvcnRhYmxlO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAvLyBDYXB0dXJlIHJlY3RzLFxuICAgICAgICAvLyBoaWRlIG11bHRpIGRyYWcgZWxlbWVudHMgKGJ5IHBvc2l0aW9uaW5nIHRoZW0gYWJzb2x1dGUpLFxuICAgICAgICAvLyBzZXQgbXVsdGkgZHJhZyBlbGVtZW50cyByZWN0cyB0byBkcmFnUmVjdCxcbiAgICAgICAgLy8gc2hvdyBtdWx0aSBkcmFnIGVsZW1lbnRzLFxuICAgICAgICAvLyBhbmltYXRlIHRvIHJlY3RzLFxuICAgICAgICAvLyB1bnNldCByZWN0cyAmIHJlbW92ZSBmcm9tIERPTVxuICAgICAgICBzb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgY3NzKG11bHRpRHJhZ0VsZW1lbnQsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzb3J0YWJsZS5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gUmVtb3ZlIGFsbCBhdXhpbGlhcnkgbXVsdGlkcmFnIGl0ZW1zIGZyb20gZWwsIGlmIHNvcnRpbmcgZW5hYmxlZFxuXG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYWdPdmVyOiBmdW5jdGlvbiBkcmFnT3ZlcihfcmVmOCkge1xuICAgICAgdmFyIHRhcmdldCA9IF9yZWY4LnRhcmdldCxcbiAgICAgICAgICBjb21wbGV0ZWQgPSBfcmVmOC5jb21wbGV0ZWQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjguY2FuY2VsO1xuXG4gICAgICBpZiAoZm9sZGluZyAmJiB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpKSB7XG4gICAgICAgIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoX3JlZjkpIHtcbiAgICAgIHZhciBmcm9tU29ydGFibGUgPSBfcmVmOS5mcm9tU29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjkucm9vdEVsLFxuICAgICAgICAgIHNvcnRhYmxlID0gX3JlZjkuc29ydGFibGUsXG4gICAgICAgICAgZHJhZ1JlY3QgPSBfcmVmOS5kcmFnUmVjdDtcblxuICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gU2V0dXAgdW5mb2xkIGFuaW1hdGlvblxuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgc29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgcmVjdDogZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLnJlbW92ZUFuaW1hdGlvblN0YXRlKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlLCByb290RWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJDb21wbGV0ZWQ6IGZ1bmN0aW9uIGRyYWdPdmVyQ29tcGxldGVkKF9yZWYxMCkge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjEwLnNvcnRhYmxlLFxuICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTAuaXNPd25lcixcbiAgICAgICAgICBpbnNlcnRpb24gPSBfcmVmMTAuaW5zZXJ0aW9uLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjEwLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgIHBhcmVudEVsID0gX3JlZjEwLnBhcmVudEVsLFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEwLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlOyAvLyBJZiBsZWF2aW5nIHNvcnQ6ZmFsc2Ugcm9vdCwgb3IgYWxyZWFkeSBmb2xkaW5nIC0gRm9sZCB0byBuZXcgbG9jYXRpb25cblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSAmJiAoZm9sZGluZyB8fCAhaXNPd25lciAmJiAhYWN0aXZlU29ydGFibGUub3B0aW9ucy5zb3J0ICYmICFwdXRTb3J0YWJsZSkpIHtcbiAgICAgICAgICAvLyBGb2xkOiBTZXQgYWxsIG11bHRpIGRyYWcgZWxlbWVudHMncyByZWN0cyB0byBkcmFnRWwncyByZWN0IHdoZW4gbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW52aXNpYmxlXG4gICAgICAgICAgdmFyIGRyYWdSZWN0QWJzb2x1dGUgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0QWJzb2x1dGUpOyAvLyBNb3ZlIGVsZW1lbnQocykgdG8gZW5kIG9mIHBhcmVudEVsIHNvIHRoYXQgaXQgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggbXVsdGktZHJhZyBjbG9uZXMgaW5zZXJ0aW9uIGlmIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAvLyB3aGlsZSBmb2xkaW5nLCBhbmQgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSB0aGVtIGFnYWluIGJlY2F1c2Ugb2xkIHNvcnRhYmxlIHdpbGwgbm8gbG9uZ2VyIGJlIGZyb21Tb3J0YWJsZVxuXG4gICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBDbG9uZXMgbXVzdCBiZSBzaG93biAoYW5kIGNoZWNrIHRvIHJlbW92ZSBtdWx0aSBkcmFncykgYWZ0ZXIgZm9sZGluZyB3aGVuIGludGVyZmVyaW5nIG11bHRpRHJhZ0VsZW1lbnRzIGFyZSBtb3ZlZCBvdXRcblxuXG4gICAgICAgIGlmICghaXNPd25lcikge1xuICAgICAgICAgIC8vIE9ubHkgcmVtb3ZlIGlmIG5vdCBmb2xkaW5nIChmb2xkaW5nIHdpbGwgcmVtb3ZlIHRoZW0gYW55d2F5cylcbiAgICAgICAgICBpZiAoIWZvbGRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZXNIaWRkZW5CZWZvcmUgPSBjbG9uZXNIaWRkZW47XG5cbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoc29ydGFibGUpOyAvLyBVbmZvbGQgYW5pbWF0aW9uIGZvciBjbG9uZXMgaWYgc2hvd2luZyBmcm9tIGhpZGRlblxuXG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhY2xvbmVzSGlkZGVuICYmIGNsb25lc0hpZGRlbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNsb25lLFxuICAgICAgICAgICAgICAgICAgcmVjdDogY2xvbmVzRnJvbVJlY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbG9uZS5mcm9tUmVjdCA9IGNsb25lc0Zyb21SZWN0O1xuICAgICAgICAgICAgICAgIGNsb25lLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlKF9yZWYxMSkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gX3JlZjExLmRyYWdSZWN0LFxuICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTEuaXNPd25lcixcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMS5hY3RpdmVTb3J0YWJsZTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhaXNPd25lciAmJiBhY3RpdmVTb3J0YWJsZS5tdWx0aURyYWcuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgY2xvbmVzRnJvbVJlY3QgPSBfZXh0ZW5kcyh7fSwgZHJhZ1JlY3QpO1xuICAgICAgICB2YXIgZHJhZ01hdHJpeCA9IG1hdHJpeChkcmFnRWwkMSwgdHJ1ZSk7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LnRvcCAtPSBkcmFnTWF0cml4LmY7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LmxlZnQgLT0gZHJhZ01hdHJpeC5lO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgIGlmIChmb2xkaW5nKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjEyKSB7XG4gICAgICB2YXIgZXZ0ID0gX3JlZjEyLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjEyLnJvb3RFbCxcbiAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMi5wYXJlbnRFbCxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWYxMi5zb3J0YWJsZSxcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMTIuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICAgIG9sZEluZGV4ID0gX3JlZjEyLm9sZEluZGV4LFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEyLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgaWYgKCFldnQpIHJldHVybjtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNoaWxkcmVuID0gcGFyZW50RWwuY2hpbGRyZW47IC8vIE11bHRpLWRyYWcgc2VsZWN0aW9uXG5cbiAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlEcmFnS2V5ICYmICF0aGlzLm11bHRpRHJhZ0tleURvd24pIHtcbiAgICAgICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsJDEsIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSk7XG5cbiAgICAgICAgaWYgKCF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGRyYWdFbCQxKTtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICB0YXJnZXRFbDogZHJhZ0VsJDEsXG4gICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgfSk7IC8vIE1vZGlmaWVyIGFjdGl2YXRlZCwgc2VsZWN0IGZyb20gbGFzdCB0byBkcmFnRWxcblxuICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgJiYgbGFzdE11bHRpRHJhZ1NlbGVjdCAmJiBzb3J0YWJsZS5lbC5jb250YWlucyhsYXN0TXVsdGlEcmFnU2VsZWN0KSkge1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4KGxhc3RNdWx0aURyYWdTZWxlY3QpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4KGRyYWdFbCQxKTtcblxuICAgICAgICAgICAgaWYgKH5sYXN0SW5kZXggJiYgfmN1cnJlbnRJbmRleCAmJiBsYXN0SW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAvLyBNdXN0IGluY2x1ZGUgbGFzdE11bHRpRHJhZ1NlbGVjdCAoc2VsZWN0IGl0KSwgaW4gY2FzZSBtb2RpZmllZCBzZWxlY3Rpb24gZnJvbSBubyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgLy8gKGJ1dCBwcmV2aW91cyBzZWxlY3Rpb24gZXhpc3RlZClcbiAgICAgICAgICAgICAgdmFyIG4sIGk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBsYXN0SW5kZXggKyAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAofm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoY2hpbGRyZW5baV0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZHJlbltpXSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICAgICAgICB0YXJnZXRFbDogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IGRyYWdFbCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UobXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSksIDEpO1xuICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBudWxsO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIE11bHRpLWRyYWcgZHJvcFxuXG5cbiAgICAgIGlmIChkcmFnU3RhcnRlZCAmJiB0aGlzLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIC8vIERvIG5vdCBcInVuZm9sZFwiIGFmdGVyIGFyb3VuZCBkcmFnRWwgaWYgcmV2ZXJ0ZWRcbiAgICAgICAgaWYgKChwYXJlbnRFbFtleHBhbmRvXS5vcHRpb25zLnNvcnQgfHwgcGFyZW50RWwgIT09IHJvb3RFbCkgJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEpLFxuICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCA9IGluZGV4KGRyYWdFbCQxLCAnOm5vdCguJyArIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nICYmIG9wdGlvbnMuYW5pbWF0aW9uKSBkcmFnRWwkMS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgZHJhZ0VsJDEuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0O1xuICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IHJlY3Q7IC8vIFByZXBhcmUgdW5mb2xkIGFuaW1hdGlvblxuXG4gICAgICAgICAgICAgICAgICB0b1NvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBNdWx0aSBkcmFnIGVsZW1lbnRzIGFyZSBub3QgbmVjZXNzYXJpbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00gb24gZHJvcCwgc28gdG8gcmVpbnNlcnRcbiAgICAgICAgICAgIC8vIHByb3Blcmx5IHRoZXkgbXVzdCBhbGwgYmUgcmVtb3ZlZFxuXG5cbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZHJlblttdWx0aURyYWdJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4Kys7XG4gICAgICAgICAgICB9KTsgLy8gSWYgaW5pdGlhbCBmb2xkaW5nIGlzIGRvbmUsIHRoZSBlbGVtZW50cyBtYXkgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9uIGJlY2F1c2UgdGhleSBhcmUgbm93XG4gICAgICAgICAgICAvLyB1bmZvbGRpbmcgYXJvdW5kIGRyYWdFbCwgZXZlbiB0aG91Z2ggZHJhZ0VsIG1heSBub3QgaGF2ZSBoaXMgaW5kZXggY2hhbmdlZCwgc28gdXBkYXRlIGV2ZW50XG4gICAgICAgICAgICAvLyBtdXN0IGJlIGZpcmVkIGhlcmUgYXMgU29ydGFibGUgd2lsbCBub3QuXG5cbiAgICAgICAgICAgIGlmIChvbGRJbmRleCA9PT0gaW5kZXgoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggIT09IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgndXBkYXRlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE11c3QgYmUgZG9uZSBhZnRlciBjYXB0dXJpbmcgaW5kaXZpZHVhbCByZWN0cyAoc2Nyb2xsIGJhcilcblxuXG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSB0b1NvcnRhYmxlO1xuICAgICAgfSAvLyBSZW1vdmUgY2xvbmVzIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUgJiYgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZ0dsb2JhbDogZnVuY3Rpb24gbnVsbGluZ0dsb2JhbCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBkZXN0cm95R2xvYmFsOiBmdW5jdGlvbiBkZXN0cm95R2xvYmFsKCkge1xuICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgICBvZmYoZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIH0sXG4gICAgX2Rlc2VsZWN0TXVsdGlEcmFnOiBmdW5jdGlvbiBfZGVzZWxlY3RNdWx0aURyYWcoZXZ0KSB7XG4gICAgICBpZiAodHlwZW9mIGRyYWdTdGFydGVkICE9PSBcInVuZGVmaW5lZFwiICYmIGRyYWdTdGFydGVkKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgc2VsZWN0aW9uIGlzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICE9PSB0aGlzLnNvcnRhYmxlKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgdGFyZ2V0IGlzIG5vdCBpdGVtIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKGV2dCAmJiBjbG9zZXN0KGV2dC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuc29ydGFibGUuZWwsIGZhbHNlKSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIGxlZnQgY2xpY2tcblxuICAgICAgaWYgKGV2dCAmJiBldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgIHdoaWxlIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVsID0gbXVsdGlEcmFnRWxlbWVudHNbMF07XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcy5zb3J0YWJsZSxcbiAgICAgICAgICByb290RWw6IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICB0YXJnZXRFbDogZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGVja0tleURvd246IGZ1bmN0aW9uIF9jaGVja0tleURvd24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoZWNrS2V5VXA6IGZ1bmN0aW9uIF9jaGVja0tleVVwKGV2dCkge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoTXVsdGlEcmFnLCB7XG4gICAgLy8gU3RhdGljIG1ldGhvZHMgJiBwcm9wZXJ0aWVzXG4gICAgcGx1Z2luTmFtZTogJ211bHRpRHJhZycsXG4gICAgdXRpbHM6IHtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIHNlbGVjdGVkXHJcbiAgICAgICAqL1xuICAgICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZWwpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXTtcbiAgICAgICAgaWYgKCFzb3J0YWJsZSB8fCAhc29ydGFibGUub3B0aW9ucy5tdWx0aURyYWcgfHwgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICYmIG11bHRpRHJhZ1NvcnRhYmxlICE9PSBzb3J0YWJsZSkge1xuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc29ydGFibGUub3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChlbCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcclxuICAgICAgICogRGVzZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIGRlc2VsZWN0ZWRcclxuICAgICAgICovXG4gICAgICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWwpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXSxcbiAgICAgICAgICAgIGluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCk7XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8ICF+aW5kZXgpIHJldHVybjtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG9sZEluZGljaWVzID0gW10sXG4gICAgICAgICAgbmV3SW5kaWNpZXMgPSBbXTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgb2xkSW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICBpbmRleDogbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4XG4gICAgICAgIH0pOyAvLyBtdWx0aURyYWdFbGVtZW50cyB3aWxsIGFscmVhZHkgYmUgc29ydGVkIGlmIGZvbGRpbmdcblxuICAgICAgICB2YXIgbmV3SW5kZXg7XG5cbiAgICAgICAgaWYgKGZvbGRpbmcgJiYgbXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbGRpbmcpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQsICc6bm90KC4nICsgX3RoaXMzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0luZGljaWVzLnB1c2goe1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtczogX3RvQ29uc3VtYWJsZUFycmF5KG11bHRpRHJhZ0VsZW1lbnRzKSxcbiAgICAgICAgY2xvbmVzOiBbXS5jb25jYXQobXVsdGlEcmFnQ2xvbmVzKSxcbiAgICAgICAgb2xkSW5kaWNpZXM6IG9sZEluZGljaWVzLFxuICAgICAgICBuZXdJbmRpY2llczogbmV3SW5kaWNpZXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBvcHRpb25MaXN0ZW5lcnM6IHtcbiAgICAgIG11bHRpRHJhZ0tleTogZnVuY3Rpb24gbXVsdGlEcmFnS2V5KGtleSkge1xuICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY3RybCcpIHtcbiAgICAgICAgICBrZXkgPSAnQ29udHJvbCc7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyhjbG9uZXNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQsIGkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW211bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCArIChjbG9uZXNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcclxuICogSW5zZXJ0IG11bHRpLWRyYWcgY2xvbmVzXHJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gZWxlbWVudHNJbnNlcnRlZCAgV2hldGhlciB0aGUgbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW5zZXJ0ZWRcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHJvb3RFbFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZWxlbWVudHNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bY2xvbmUuc29ydGFibGVJbmRleCArIChlbGVtZW50c0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZSwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZSAmJiBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gIH0pO1xufVxuXG5Tb3J0YWJsZS5tb3VudChuZXcgQXV0b1Njcm9sbFBsdWdpbigpKTtcblNvcnRhYmxlLm1vdW50KFJlbW92ZSwgUmV2ZXJ0KTtcblxuZXhwb3J0IGRlZmF1bHQgU29ydGFibGU7XG5leHBvcnQgeyBNdWx0aURyYWdQbHVnaW4gYXMgTXVsdGlEcmFnLCBTb3J0YWJsZSwgU3dhcFBsdWdpbiBhcyBTd2FwIH07XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJzb3J0YWJsZWpzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInNvcnRhYmxlanNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widnVlZHJhZ2dhYmxlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwic29ydGFibGVqc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1widnVlZHJhZ2dhYmxlXCJdID0gZmFjdG9yeShyb290W1wiU29ydGFibGVcIl0pO1xufSkoKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKSwgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9hMzUyX18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCJmYjE1XCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZXhlYycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhcbiAgICAgIGRlZmluZWQsXG4gICAgICBTWU1CT0wsXG4gICAgICAnJ1tLRVldLFxuICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi41JyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYTM1Ml9fOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5yZXF1aXJlKCcuL19leHBvcnQnKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pO1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiZnVuY3Rpb24gZ2V0Q29uc29sZSgpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5jb25zb2xlO1xyXG4gIH1cclxuICByZXR1cm4gZ2xvYmFsLmNvbnNvbGU7XHJcbn1cclxuY29uc3QgY29uc29sZSA9IGdldENvbnNvbGUoKTtcclxuXHJcbmZ1bmN0aW9uIGNhY2hlZChmbikge1xyXG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkRm4oc3RyKSB7XHJcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IHJlZ2V4ID0gLy0oXFx3KS9nO1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlZChzdHIgPT5cclxuICBzdHIucmVwbGFjZShyZWdleCwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIikpXHJcbik7XHJcblxyXG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcclxuICBpZiAobm9kZS5wYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XHJcbiAgICBub2RlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnROb2RlQXQoZmF0aGVyTm9kZSwgbm9kZSwgcG9zaXRpb24pIHtcclxuICBjb25zdCByZWZOb2RlID1cclxuICAgIHBvc2l0aW9uID09PSAwXHJcbiAgICAgID8gZmF0aGVyTm9kZS5jaGlsZHJlblswXVxyXG4gICAgICA6IGZhdGhlck5vZGUuY2hpbGRyZW5bcG9zaXRpb24gLSAxXS5uZXh0U2libGluZztcclxuICBmYXRoZXJOb2RlLmluc2VydEJlZm9yZShub2RlLCByZWZOb2RlKTtcclxufVxyXG5cclxuZXhwb3J0IHsgaW5zZXJ0Tm9kZUF0LCBjYW1lbGl6ZSwgY29uc29sZSwgcmVtb3ZlTm9kZSB9O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG4iLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCIvLyBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHBvbHlmaWxsIGJ5IEFkYW0gTWlsbGVyXG5cbi8vIE1JVCBsaWNlbnNlXG5cbihmdW5jdGlvbihkb2N1bWVudCl7XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gXCJjdXJyZW50U2NyaXB0XCIsXG4gICAgICBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpOyAvLyBMaXZlIE5vZGVMaXN0IGNvbGxlY3Rpb25cblxuICAvLyBJZiBicm93c2VyIG5lZWRzIGN1cnJlbnRTY3JpcHQgcG9seWZpbGwsIGFkZCBnZXQgY3VycmVudFNjcmlwdCgpIHRvIHRoZSBkb2N1bWVudCBvYmplY3RcbiAgaWYgKCEoY3VycmVudFNjcmlwdCBpbiBkb2N1bWVudCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsIGN1cnJlbnRTY3JpcHQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcblxuICAgICAgICAvLyBJRSA2LTEwIHN1cHBvcnRzIHNjcmlwdCByZWFkeVN0YXRlXG4gICAgICAgIC8vIElFIDEwKyBzdXBwb3J0IHN0YWNrIHRyYWNlXG4gICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIHNlY29uZCBtYXRjaCBmb3IgdGhlIFwiYXRcIiBzdHJpbmcgdG8gZ2V0IGZpbGUgc3JjIHVybCBmcm9tIHN0YWNrLlxuICAgICAgICAgIC8vIFNwZWNpZmljYWxseSB3b3JrcyB3aXRoIHRoZSBmb3JtYXQgb2Ygc3RhY2sgdHJhY2VzIGluIElFLlxuICAgICAgICAgIHZhciBpLCByZXMgPSAoKC8uKmF0IFteXFwoXSpcXCgoLiopOi4rOi4rXFwpJC9pZykuZXhlYyhlcnIuc3RhY2spIHx8IFtmYWxzZV0pWzFdO1xuXG4gICAgICAgICAgLy8gRm9yIGFsbCBzY3JpcHRzIG9uIHRoZSBwYWdlLCBpZiBzcmMgbWF0Y2hlcyBvciBpZiByZWFkeSBzdGF0ZSBpcyBpbnRlcmFjdGl2ZSwgcmV0dXJuIHRoZSBzY3JpcHQgdGFnXG4gICAgICAgICAgZm9yKGkgaW4gc2NyaXB0cyl7XG4gICAgICAgICAgICBpZihzY3JpcHRzW2ldLnNyYyA9PSByZXMgfHwgc2NyaXB0c1tpXS5yZWFkeVN0YXRlID09IFwiaW50ZXJhY3RpdmVcIil7XG4gICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIG5vIG1hdGNoLCByZXR1cm4gbnVsbFxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pKGRvY3VtZW50KTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBpbnRvIGxpYi93YyBjbGllbnQgYnVuZGxlcy5cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5ORUVEX0NVUlJFTlRTQ1JJUFRfUE9MWUZJTEwpIHtcbiAgICByZXF1aXJlKCdjdXJyZW50LXNjcmlwdC1wb2x5ZmlsbCcpXG4gIH1cblxuICB2YXIgaVxuICBpZiAoKGkgPSB3aW5kb3cuZG9jdW1lbnQuY3VycmVudFNjcmlwdCkgJiYgKGkgPSBpLnNyYy5tYXRjaCgvKC4rXFwvKVteL10rXFwuanMoXFw/LiopPyQvKSkpIHtcbiAgICBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IGlbMV0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG59XG5cbi8vIEluZGljYXRlIHRvIHdlYnBhY2sgdGhhdCB0aGlzIGZpbGUgY2FuIGJlIGNvbmNhdGVuYXRlZFxuZXhwb3J0IGRlZmF1bHQgbnVsbFxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBhcnJheVdpdGhIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhIb2xlc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheUxpbWl0IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCBub25JdGVyYWJsZVJlc3QgZnJvbSBcIi4vbm9uSXRlcmFibGVSZXN0XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRob3V0SG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRob3V0SG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tIFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59IiwiaW1wb3J0IFNvcnRhYmxlIGZyb20gXCJzb3J0YWJsZWpzXCI7XHJcbmltcG9ydCB7IGluc2VydE5vZGVBdCwgY2FtZWxpemUsIGNvbnNvbGUsIHJlbW92ZU5vZGUgfSBmcm9tIFwiLi91dGlsL2hlbHBlclwiO1xyXG5cclxuZnVuY3Rpb24gYnVpbGRBdHRyaWJ1dGUob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcclxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG9iamVjdDtcclxuICB9XHJcbiAgb2JqZWN0ID0gb2JqZWN0IHx8IHt9O1xyXG4gIG9iamVjdFtwcm9wTmFtZV0gPSB2YWx1ZTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlVm1JbmRleCh2bm9kZXMsIGVsZW1lbnQpIHtcclxuICByZXR1cm4gdm5vZGVzLm1hcChlbHQgPT4gZWx0LmVsbSkuaW5kZXhPZihlbGVtZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZUluZGV4ZXMoc2xvdHMsIGNoaWxkcmVuLCBpc1RyYW5zaXRpb24sIGZvb3Rlck9mZnNldCkge1xyXG4gIGlmICghc2xvdHMpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGVsbUZyb21Ob2RlcyA9IHNsb3RzLm1hcChlbHQgPT4gZWx0LmVsbSk7XHJcbiAgY29uc3QgZm9vdGVySW5kZXggPSBjaGlsZHJlbi5sZW5ndGggLSBmb290ZXJPZmZzZXQ7XHJcbiAgY29uc3QgcmF3SW5kZXhlcyA9IFsuLi5jaGlsZHJlbl0ubWFwKChlbHQsIGlkeCkgPT5cclxuICAgIGlkeCA+PSBmb290ZXJJbmRleCA/IGVsbUZyb21Ob2Rlcy5sZW5ndGggOiBlbG1Gcm9tTm9kZXMuaW5kZXhPZihlbHQpXHJcbiAgKTtcclxuICByZXR1cm4gaXNUcmFuc2l0aW9uID8gcmF3SW5kZXhlcy5maWx0ZXIoaW5kID0+IGluZCAhPT0gLTEpIDogcmF3SW5kZXhlcztcclxufVxyXG5cclxuZnVuY3Rpb24gZW1pdChldnROYW1lLCBldnREYXRhKSB7XHJcbiAgdGhpcy4kbmV4dFRpY2soKCkgPT4gdGhpcy4kZW1pdChldnROYW1lLnRvTG93ZXJDYXNlKCksIGV2dERhdGEpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVsZWdhdGVBbmRFbWl0KGV2dE5hbWUpIHtcclxuICByZXR1cm4gZXZ0RGF0YSA9PiB7XHJcbiAgICBpZiAodGhpcy5yZWFsTGlzdCAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzW1wib25EcmFnXCIgKyBldnROYW1lXShldnREYXRhKTtcclxuICAgIH1cclxuICAgIGVtaXQuY2FsbCh0aGlzLCBldnROYW1lLCBldnREYXRhKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RyYW5zaXRpb25OYW1lKG5hbWUpIHtcclxuICByZXR1cm4gW1widHJhbnNpdGlvbi1ncm91cFwiLCBcIlRyYW5zaXRpb25Hcm91cFwiXS5pbmNsdWRlcyhuYW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uKHNsb3RzKSB7XHJcbiAgaWYgKCFzbG90cyB8fCBzbG90cy5sZW5ndGggIT09IDEpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3QgW3sgY29tcG9uZW50T3B0aW9ucyB9XSA9IHNsb3RzO1xyXG4gIGlmICghY29tcG9uZW50T3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gaXNUcmFuc2l0aW9uTmFtZShjb21wb25lbnRPcHRpb25zLnRhZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNsb3Qoc2xvdCwgc2NvcGVkU2xvdCwga2V5KSB7XHJcbiAgcmV0dXJuIHNsb3Rba2V5XSB8fCAoc2NvcGVkU2xvdFtrZXldID8gc2NvcGVkU2xvdFtrZXldKCkgOiB1bmRlZmluZWQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlQ2hpbGRyZW5BbmRPZmZzZXRzKGNoaWxkcmVuLCBzbG90LCBzY29wZWRTbG90KSB7XHJcbiAgbGV0IGhlYWRlck9mZnNldCA9IDA7XHJcbiAgbGV0IGZvb3Rlck9mZnNldCA9IDA7XHJcbiAgY29uc3QgaGVhZGVyID0gZ2V0U2xvdChzbG90LCBzY29wZWRTbG90LCBcImhlYWRlclwiKTtcclxuICBpZiAoaGVhZGVyKSB7XHJcbiAgICBoZWFkZXJPZmZzZXQgPSBoZWFkZXIubGVuZ3RoO1xyXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbiA/IFsuLi5oZWFkZXIsIC4uLmNoaWxkcmVuXSA6IFsuLi5oZWFkZXJdO1xyXG4gIH1cclxuICBjb25zdCBmb290ZXIgPSBnZXRTbG90KHNsb3QsIHNjb3BlZFNsb3QsIFwiZm9vdGVyXCIpO1xyXG4gIGlmIChmb290ZXIpIHtcclxuICAgIGZvb3Rlck9mZnNldCA9IGZvb3Rlci5sZW5ndGg7XHJcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuID8gWy4uLmNoaWxkcmVuLCAuLi5mb290ZXJdIDogWy4uLmZvb3Rlcl07XHJcbiAgfVxyXG4gIHJldHVybiB7IGNoaWxkcmVuLCBoZWFkZXJPZmZzZXQsIGZvb3Rlck9mZnNldCB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRBdHRyaWJ1dGVzKCRhdHRycywgY29tcG9uZW50RGF0YSkge1xyXG4gIGxldCBhdHRyaWJ1dGVzID0gbnVsbDtcclxuICBjb25zdCB1cGRhdGUgPSAobmFtZSwgdmFsdWUpID0+IHtcclxuICAgIGF0dHJpYnV0ZXMgPSBidWlsZEF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBuYW1lLCB2YWx1ZSk7XHJcbiAgfTtcclxuICBjb25zdCBhdHRycyA9IE9iamVjdC5rZXlzKCRhdHRycylcclxuICAgIC5maWx0ZXIoa2V5ID0+IGtleSA9PT0gXCJpZFwiIHx8IGtleS5zdGFydHNXaXRoKFwiZGF0YS1cIikpXHJcbiAgICAucmVkdWNlKChyZXMsIGtleSkgPT4ge1xyXG4gICAgICByZXNba2V5XSA9ICRhdHRyc1trZXldO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSwge30pO1xyXG4gIHVwZGF0ZShcImF0dHJzXCIsIGF0dHJzKTtcclxuXHJcbiAgaWYgKCFjb21wb25lbnREYXRhKSB7XHJcbiAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICB9XHJcbiAgY29uc3QgeyBvbiwgcHJvcHMsIGF0dHJzOiBjb21wb25lbnREYXRhQXR0cnMgfSA9IGNvbXBvbmVudERhdGE7XHJcbiAgdXBkYXRlKFwib25cIiwgb24pO1xyXG4gIHVwZGF0ZShcInByb3BzXCIsIHByb3BzKTtcclxuICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMuYXR0cnMsIGNvbXBvbmVudERhdGFBdHRycyk7XHJcbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbn1cclxuXHJcbmNvbnN0IGV2ZW50c0xpc3RlbmVkID0gW1wiU3RhcnRcIiwgXCJBZGRcIiwgXCJSZW1vdmVcIiwgXCJVcGRhdGVcIiwgXCJFbmRcIl07XHJcbmNvbnN0IGV2ZW50c1RvRW1pdCA9IFtcIkNob29zZVwiLCBcIlVuY2hvb3NlXCIsIFwiU29ydFwiLCBcIkZpbHRlclwiLCBcIkNsb25lXCJdO1xyXG5jb25zdCByZWFkb25seVByb3BlcnRpZXMgPSBbXCJNb3ZlXCIsIC4uLmV2ZW50c0xpc3RlbmVkLCAuLi5ldmVudHNUb0VtaXRdLm1hcChcclxuICBldnQgPT4gXCJvblwiICsgZXZ0XHJcbik7XHJcbnZhciBkcmFnZ2luZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuY29uc3QgcHJvcHMgPSB7XHJcbiAgb3B0aW9uczogT2JqZWN0LFxyXG4gIGxpc3Q6IHtcclxuICAgIHR5cGU6IEFycmF5LFxyXG4gICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgZGVmYXVsdDogbnVsbFxyXG4gIH0sXHJcbiAgdmFsdWU6IHtcclxuICAgIHR5cGU6IEFycmF5LFxyXG4gICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgZGVmYXVsdDogbnVsbFxyXG4gIH0sXHJcbiAgbm9UcmFuc2l0aW9uT25EcmFnOiB7XHJcbiAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgZGVmYXVsdDogZmFsc2VcclxuICB9LFxyXG4gIGNsb25lOiB7XHJcbiAgICB0eXBlOiBGdW5jdGlvbixcclxuICAgIGRlZmF1bHQ6IG9yaWdpbmFsID0+IHtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZWxlbWVudDoge1xyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgZGVmYXVsdDogXCJkaXZcIlxyXG4gIH0sXHJcbiAgdGFnOiB7XHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBkZWZhdWx0OiBudWxsXHJcbiAgfSxcclxuICBtb3ZlOiB7XHJcbiAgICB0eXBlOiBGdW5jdGlvbixcclxuICAgIGRlZmF1bHQ6IG51bGxcclxuICB9LFxyXG4gIGNvbXBvbmVudERhdGE6IHtcclxuICAgIHR5cGU6IE9iamVjdCxcclxuICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgIGRlZmF1bHQ6IG51bGxcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBkcmFnZ2FibGVDb21wb25lbnQgPSB7XHJcbiAgbmFtZTogXCJkcmFnZ2FibGVcIixcclxuXHJcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcclxuXHJcbiAgcHJvcHMsXHJcblxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0cmFuc2l0aW9uTW9kZTogZmFsc2UsXHJcbiAgICAgIG5vbmVGdW5jdGlvbmFsQ29tcG9uZW50TW9kZTogZmFsc2VcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyKGgpIHtcclxuICAgIGNvbnN0IHNsb3RzID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcclxuICAgIHRoaXMudHJhbnNpdGlvbk1vZGUgPSBpc1RyYW5zaXRpb24oc2xvdHMpO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaGVhZGVyT2Zmc2V0LCBmb290ZXJPZmZzZXQgfSA9IGNvbXB1dGVDaGlsZHJlbkFuZE9mZnNldHMoXHJcbiAgICAgIHNsb3RzLFxyXG4gICAgICB0aGlzLiRzbG90cyxcclxuICAgICAgdGhpcy4kc2NvcGVkU2xvdHNcclxuICAgICk7XHJcbiAgICB0aGlzLmhlYWRlck9mZnNldCA9IGhlYWRlck9mZnNldDtcclxuICAgIHRoaXMuZm9vdGVyT2Zmc2V0ID0gZm9vdGVyT2Zmc2V0O1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldENvbXBvbmVudEF0dHJpYnV0ZXModGhpcy4kYXR0cnMsIHRoaXMuY29tcG9uZW50RGF0YSk7XHJcbiAgICByZXR1cm4gaCh0aGlzLmdldFRhZygpLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlZCgpIHtcclxuICAgIGlmICh0aGlzLmxpc3QgIT09IG51bGwgJiYgdGhpcy52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgIFwiVmFsdWUgYW5kIGxpc3QgcHJvcHMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSEgUGxlYXNlIHNldCBvbmUgb3IgYW5vdGhlci5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmVsZW1lbnQgIT09IFwiZGl2XCIpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIFwiRWxlbWVudCBwcm9wcyBpcyBkZXByZWNhdGVkIHBsZWFzZSB1c2UgdGFnIHByb3BzIGluc3RlYWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vU29ydGFibGVKUy9WdWUuRHJhZ2dhYmxlL2Jsb2IvbWFzdGVyL2RvY3VtZW50YXRpb24vbWlncmF0ZS5tZCNlbGVtZW50LXByb3BzXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIFwiT3B0aW9ucyBwcm9wcyBpcyBkZXByZWNhdGVkLCBhZGQgc29ydGFibGUgb3B0aW9ucyBkaXJlY3RseSBhcyB2dWUuZHJhZ2dhYmxlIGl0ZW0sIG9yIHVzZSB2LWJpbmQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vU29ydGFibGVKUy9WdWUuRHJhZ2dhYmxlL2Jsb2IvbWFzdGVyL2RvY3VtZW50YXRpb24vbWlncmF0ZS5tZCNvcHRpb25zLXByb3BzXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5ub25lRnVuY3Rpb25hbENvbXBvbmVudE1vZGUgPVxyXG4gICAgICB0aGlzLmdldFRhZygpLnRvTG93ZXJDYXNlKCkgIT09IHRoaXMuJGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgIXRoaXMuZ2V0SXNGdW5jdGlvbmFsKCk7XHJcbiAgICBpZiAodGhpcy5ub25lRnVuY3Rpb25hbENvbXBvbmVudE1vZGUgJiYgdGhpcy50cmFuc2l0aW9uTW9kZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYFRyYW5zaXRpb24tZ3JvdXAgaW5zaWRlIGNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgYWx0ZXIgdGFnIHZhbHVlIG9yIHJlbW92ZSB0cmFuc2l0aW9uLWdyb3VwLiBDdXJyZW50IHRhZyB2YWx1ZTogJHt0aGlzLmdldFRhZygpfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9wdGlvbnNBZGRlZCA9IHt9O1xyXG4gICAgZXZlbnRzTGlzdGVuZWQuZm9yRWFjaChlbHQgPT4ge1xyXG4gICAgICBvcHRpb25zQWRkZWRbXCJvblwiICsgZWx0XSA9IGRlbGVnYXRlQW5kRW1pdC5jYWxsKHRoaXMsIGVsdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBldmVudHNUb0VtaXQuZm9yRWFjaChlbHQgPT4ge1xyXG4gICAgICBvcHRpb25zQWRkZWRbXCJvblwiICsgZWx0XSA9IGVtaXQuYmluZCh0aGlzLCBlbHQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMuJGF0dHJzKS5yZWR1Y2UoKHJlcywga2V5KSA9PiB7XHJcbiAgICAgIHJlc1tjYW1lbGl6ZShrZXkpXSA9IHRoaXMuJGF0dHJzW2tleV07XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgYXR0cmlidXRlcywgb3B0aW9uc0FkZGVkLCB7XHJcbiAgICAgIG9uTW92ZTogKGV2dCwgb3JpZ2luYWxFdmVudCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9uRHJhZ01vdmUoZXZ0LCBvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAhKFwiZHJhZ2dhYmxlXCIgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnMuZHJhZ2dhYmxlID0gXCI+KlwiKTtcclxuICAgIHRoaXMuX3NvcnRhYmxlID0gbmV3IFNvcnRhYmxlKHRoaXMucm9vdENvbnRhaW5lciwgb3B0aW9ucyk7XHJcbiAgICB0aGlzLmNvbXB1dGVJbmRleGVzKCk7XHJcbiAgfSxcclxuXHJcbiAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLl9zb3J0YWJsZSAhPT0gdW5kZWZpbmVkKSB0aGlzLl9zb3J0YWJsZS5kZXN0cm95KCk7XHJcbiAgfSxcclxuXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHJvb3RDb250YWluZXIoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Nb2RlID8gdGhpcy4kZWwuY2hpbGRyZW5bMF0gOiB0aGlzLiRlbDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhbExpc3QoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxpc3QgPyB0aGlzLmxpc3QgOiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHdhdGNoOiB7XHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgIGhhbmRsZXIobmV3T3B0aW9uVmFsdWUpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMobmV3T3B0aW9uVmFsdWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBkZWVwOiB0cnVlXHJcbiAgICB9LFxyXG5cclxuICAgICRhdHRyczoge1xyXG4gICAgICBoYW5kbGVyKG5ld09wdGlvblZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKG5ld09wdGlvblZhbHVlKTtcclxuICAgICAgfSxcclxuICAgICAgZGVlcDogdHJ1ZVxyXG4gICAgfSxcclxuXHJcbiAgICByZWFsTGlzdCgpIHtcclxuICAgICAgdGhpcy5jb21wdXRlSW5kZXhlcygpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG1ldGhvZHM6IHtcclxuICAgIGdldElzRnVuY3Rpb25hbCgpIHtcclxuICAgICAgY29uc3QgeyBmbk9wdGlvbnMgfSA9IHRoaXMuX3Zub2RlO1xyXG4gICAgICByZXR1cm4gZm5PcHRpb25zICYmIGZuT3B0aW9ucy5mdW5jdGlvbmFsO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUYWcoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRhZyB8fCB0aGlzLmVsZW1lbnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9wdGlvbnMobmV3T3B0aW9uVmFsdWUpIHtcclxuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gbmV3T3B0aW9uVmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNhbWVsaXplKHByb3BlcnR5KTtcclxuICAgICAgICBpZiAocmVhZG9ubHlQcm9wZXJ0aWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xyXG4gICAgICAgICAgdGhpcy5fc29ydGFibGUub3B0aW9uKHZhbHVlLCBuZXdPcHRpb25WYWx1ZVtwcm9wZXJ0eV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDaGlsZHJlbk5vZGVzKCkge1xyXG4gICAgICBpZiAodGhpcy5ub25lRnVuY3Rpb25hbENvbXBvbmVudE1vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kY2hpbGRyZW5bMF0uJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmF3Tm9kZXMgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xyXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uTW9kZSA/IHJhd05vZGVzWzBdLmNoaWxkLiRzbG90cy5kZWZhdWx0IDogcmF3Tm9kZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbXB1dGVJbmRleGVzKCkge1xyXG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlSW5kZXhlcyA9IGNvbXB1dGVJbmRleGVzKFxyXG4gICAgICAgICAgdGhpcy5nZXRDaGlsZHJlbk5vZGVzKCksXHJcbiAgICAgICAgICB0aGlzLnJvb3RDb250YWluZXIuY2hpbGRyZW4sXHJcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Nb2RlLFxyXG4gICAgICAgICAgdGhpcy5mb290ZXJPZmZzZXRcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VW5kZXJseWluZ1ZtKGh0bWxFbHQpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb21wdXRlVm1JbmRleCh0aGlzLmdldENoaWxkcmVuTm9kZXMoKSB8fCBbXSwgaHRtbEVsdCk7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAvL0VkZ2UgY2FzZSBkdXJpbmcgbW92ZSBjYWxsYmFjazogcmVsYXRlZCBlbGVtZW50IG1pZ2h0IGJlXHJcbiAgICAgICAgLy9hbiBlbGVtZW50IGRpZmZlcmVudCBmcm9tIGNvbGxlY3Rpb25cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5yZWFsTGlzdFtpbmRleF07XHJcbiAgICAgIHJldHVybiB7IGluZGV4LCBlbGVtZW50IH07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVuZGVybHlpbmdQb3RlbmNpYWxEcmFnZ2FibGVDb21wb25lbnQoeyBfX3Z1ZV9fOiB2dWUgfSkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXZ1ZSB8fFxyXG4gICAgICAgICF2dWUuJG9wdGlvbnMgfHxcclxuICAgICAgICAhaXNUcmFuc2l0aW9uTmFtZSh2dWUuJG9wdGlvbnMuX2NvbXBvbmVudFRhZylcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgIShcInJlYWxMaXN0XCIgaW4gdnVlKSAmJlxyXG4gICAgICAgICAgdnVlLiRjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgIFwicmVhbExpc3RcIiBpbiB2dWUuJGNoaWxkcmVuWzBdXHJcbiAgICAgICAgKVxyXG4gICAgICAgICAgcmV0dXJuIHZ1ZS4kY2hpbGRyZW5bMF07XHJcblxyXG4gICAgICAgIHJldHVybiB2dWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZ1ZS4kcGFyZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0Q2hhbmdlcyhldnQpIHtcclxuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuJGVtaXQoXCJjaGFuZ2VcIiwgZXZ0KTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFsdGVyTGlzdChvbkxpc3QpIHtcclxuICAgICAgaWYgKHRoaXMubGlzdCkge1xyXG4gICAgICAgIG9uTGlzdCh0aGlzLmxpc3QpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBuZXdMaXN0ID0gWy4uLnRoaXMudmFsdWVdO1xyXG4gICAgICBvbkxpc3QobmV3TGlzdCk7XHJcbiAgICAgIHRoaXMuJGVtaXQoXCJpbnB1dFwiLCBuZXdMaXN0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3BsaWNlTGlzdCgpIHtcclxuICAgICAgY29uc3Qgc3BsaWNlTGlzdCA9IGxpc3QgPT4gbGlzdC5zcGxpY2UoLi4uYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5hbHRlckxpc3Qoc3BsaWNlTGlzdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVBvc2l0aW9uKG9sZEluZGV4LCBuZXdJbmRleCkge1xyXG4gICAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGxpc3QgPT5cclxuICAgICAgICBsaXN0LnNwbGljZShuZXdJbmRleCwgMCwgbGlzdC5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKTtcclxuICAgICAgdGhpcy5hbHRlckxpc3QodXBkYXRlUG9zaXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZWxhdGVkQ29udGV4dEZyb21Nb3ZlRXZlbnQoeyB0bywgcmVsYXRlZCB9KSB7XHJcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0VW5kZXJseWluZ1BvdGVuY2lhbERyYWdnYWJsZUNvbXBvbmVudCh0byk7XHJcbiAgICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50IH07XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbGlzdCA9IGNvbXBvbmVudC5yZWFsTGlzdDtcclxuICAgICAgY29uc3QgY29udGV4dCA9IHsgbGlzdCwgY29tcG9uZW50IH07XHJcbiAgICAgIGlmICh0byAhPT0gcmVsYXRlZCAmJiBsaXN0ICYmIGNvbXBvbmVudC5nZXRVbmRlcmx5aW5nVm0pIHtcclxuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGNvbXBvbmVudC5nZXRVbmRlcmx5aW5nVm0ocmVsYXRlZCk7XHJcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XHJcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZXN0aW5hdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRWbUluZGV4KGRvbUluZGV4KSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLnZpc2libGVJbmRleGVzO1xyXG4gICAgICBjb25zdCBudW1iZXJJbmRleGVzID0gaW5kZXhlcy5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBkb21JbmRleCA+IG51bWJlckluZGV4ZXMgLSAxID8gbnVtYmVySW5kZXhlcyA6IGluZGV4ZXNbZG9tSW5kZXhdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0WzBdLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldFRyYW5zaXRpb25EYXRhKGluZGV4KSB7XHJcbiAgICAgIGlmICghdGhpcy5ub1RyYW5zaXRpb25PbkRyYWcgfHwgIXRoaXMudHJhbnNpdGlvbk1vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5nZXRDaGlsZHJlbk5vZGVzKCk7XHJcbiAgICAgIG5vZGVzW2luZGV4XS5kYXRhID0gbnVsbDtcclxuICAgICAgY29uc3QgdHJhbnNpdGlvbkNvbnRhaW5lciA9IHRoaXMuZ2V0Q29tcG9uZW50KCk7XHJcbiAgICAgIHRyYW5zaXRpb25Db250YWluZXIuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgdHJhbnNpdGlvbkNvbnRhaW5lci5rZXB0ID0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkRyYWdTdGFydChldnQpIHtcclxuICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5nZXRVbmRlcmx5aW5nVm0oZXZ0Lml0ZW0pO1xyXG4gICAgICBldnQuaXRlbS5fdW5kZXJseWluZ192bV8gPSB0aGlzLmNsb25lKHRoaXMuY29udGV4dC5lbGVtZW50KTtcclxuICAgICAgZHJhZ2dpbmdFbGVtZW50ID0gZXZ0Lml0ZW07XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRHJhZ0FkZChldnQpIHtcclxuICAgICAgY29uc3QgZWxlbWVudCA9IGV2dC5pdGVtLl91bmRlcmx5aW5nX3ZtXztcclxuICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICByZW1vdmVOb2RlKGV2dC5pdGVtKTtcclxuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLmdldFZtSW5kZXgoZXZ0Lm5ld0luZGV4KTtcclxuICAgICAgdGhpcy5zcGxpY2VMaXN0KG5ld0luZGV4LCAwLCBlbGVtZW50KTtcclxuICAgICAgdGhpcy5jb21wdXRlSW5kZXhlcygpO1xyXG4gICAgICBjb25zdCBhZGRlZCA9IHsgZWxlbWVudCwgbmV3SW5kZXggfTtcclxuICAgICAgdGhpcy5lbWl0Q2hhbmdlcyh7IGFkZGVkIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkRyYWdSZW1vdmUoZXZ0KSB7XHJcbiAgICAgIGluc2VydE5vZGVBdCh0aGlzLnJvb3RDb250YWluZXIsIGV2dC5pdGVtLCBldnQub2xkSW5kZXgpO1xyXG4gICAgICBpZiAoZXZ0LnB1bGxNb2RlID09PSBcImNsb25lXCIpIHtcclxuICAgICAgICByZW1vdmVOb2RlKGV2dC5jbG9uZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5jb250ZXh0LmluZGV4O1xyXG4gICAgICB0aGlzLnNwbGljZUxpc3Qob2xkSW5kZXgsIDEpO1xyXG4gICAgICBjb25zdCByZW1vdmVkID0geyBlbGVtZW50OiB0aGlzLmNvbnRleHQuZWxlbWVudCwgb2xkSW5kZXggfTtcclxuICAgICAgdGhpcy5yZXNldFRyYW5zaXRpb25EYXRhKG9sZEluZGV4KTtcclxuICAgICAgdGhpcy5lbWl0Q2hhbmdlcyh7IHJlbW92ZWQgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRHJhZ1VwZGF0ZShldnQpIHtcclxuICAgICAgcmVtb3ZlTm9kZShldnQuaXRlbSk7XHJcbiAgICAgIGluc2VydE5vZGVBdChldnQuZnJvbSwgZXZ0Lml0ZW0sIGV2dC5vbGRJbmRleCk7XHJcbiAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5jb250ZXh0LmluZGV4O1xyXG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuZ2V0Vm1JbmRleChldnQubmV3SW5kZXgpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKG9sZEluZGV4LCBuZXdJbmRleCk7XHJcbiAgICAgIGNvbnN0IG1vdmVkID0geyBlbGVtZW50OiB0aGlzLmNvbnRleHQuZWxlbWVudCwgb2xkSW5kZXgsIG5ld0luZGV4IH07XHJcbiAgICAgIHRoaXMuZW1pdENoYW5nZXMoeyBtb3ZlZCB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUHJvcGVydHkoZXZ0LCBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgZXZ0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiZcclxuICAgICAgICAoZXZ0W3Byb3BlcnR5TmFtZV0gKz0gdGhpcy5oZWFkZXJPZmZzZXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21wdXRlRnV0dXJlSW5kZXgocmVsYXRlZENvbnRleHQsIGV2dCkge1xyXG4gICAgICBpZiAoIXJlbGF0ZWRDb250ZXh0LmVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkb21DaGlsZHJlbiA9IFsuLi5ldnQudG8uY2hpbGRyZW5dLmZpbHRlcihcclxuICAgICAgICBlbCA9PiBlbC5zdHlsZVtcImRpc3BsYXlcIl0gIT09IFwibm9uZVwiXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRET01JbmRleCA9IGRvbUNoaWxkcmVuLmluZGV4T2YoZXZ0LnJlbGF0ZWQpO1xyXG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSByZWxhdGVkQ29udGV4dC5jb21wb25lbnQuZ2V0Vm1JbmRleChjdXJyZW50RE9NSW5kZXgpO1xyXG4gICAgICBjb25zdCBkcmFnZ2VkSW5MaXN0ID0gZG9tQ2hpbGRyZW4uaW5kZXhPZihkcmFnZ2luZ0VsZW1lbnQpICE9PSAtMTtcclxuICAgICAgcmV0dXJuIGRyYWdnZWRJbkxpc3QgfHwgIWV2dC53aWxsSW5zZXJ0QWZ0ZXJcclxuICAgICAgICA/IGN1cnJlbnRJbmRleFxyXG4gICAgICAgIDogY3VycmVudEluZGV4ICsgMTtcclxuICAgIH0sXHJcblxyXG4gICAgb25EcmFnTW92ZShldnQsIG9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgY29uc3Qgb25Nb3ZlID0gdGhpcy5tb3ZlO1xyXG4gICAgICBpZiAoIW9uTW92ZSB8fCAhdGhpcy5yZWFsTGlzdCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZWxhdGVkQ29udGV4dCA9IHRoaXMuZ2V0UmVsYXRlZENvbnRleHRGcm9tTW92ZUV2ZW50KGV2dCk7XHJcbiAgICAgIGNvbnN0IGRyYWdnZWRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICBjb25zdCBmdXR1cmVJbmRleCA9IHRoaXMuY29tcHV0ZUZ1dHVyZUluZGV4KHJlbGF0ZWRDb250ZXh0LCBldnQpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKGRyYWdnZWRDb250ZXh0LCB7IGZ1dHVyZUluZGV4IH0pO1xyXG4gICAgICBjb25zdCBzZW5kRXZ0ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZ0LCB7XHJcbiAgICAgICAgcmVsYXRlZENvbnRleHQsXHJcbiAgICAgICAgZHJhZ2dlZENvbnRleHRcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBvbk1vdmUoc2VuZEV2dCwgb3JpZ2luYWxFdmVudCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRHJhZ0VuZCgpIHtcclxuICAgICAgdGhpcy5jb21wdXRlSW5kZXhlcygpO1xyXG4gICAgICBkcmFnZ2luZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVnVlXCIgaW4gd2luZG93KSB7XHJcbiAgd2luZG93LlZ1ZS5jb21wb25lbnQoXCJkcmFnZ2FibGVcIiwgZHJhZ2dhYmxlQ29tcG9uZW50KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZHJhZ2dhYmxlQ29tcG9uZW50O1xyXG4iLCJpbXBvcnQgJy4vc2V0UHVibGljUGF0aCdcbmltcG9ydCBtb2QgZnJvbSAnfmVudHJ5J1xuZXhwb3J0IGRlZmF1bHQgbW9kXG5leHBvcnQgKiBmcm9tICd+ZW50cnknXG4iLCJcbndpbmRvdy5tYWluRXZlbnRIdWIgPSB7XG4gIGVtaXQ6IGZ1bmN0aW9uKGh1YixldmVudCwgLi4uYXJncylcbiAge1xuICAgIGlmKHdpbmRvdy5tYWluRXZlbnRIdWJbaHViXSA9PSB1bmRlZmluZWQpIHdpbmRvdy5tYWluRXZlbnRIdWJbaHViXSA9IG5ldyBWdWUoKTtcbiAgICByZXR1cm4gd2luZG93Lm1haW5FdmVudEh1YltodWJdLiRlbWl0KGV2ZW50LCBhcmdzKTtcbiAgfSxcbiAgb246IGZ1bmN0aW9uKGh1YixldmVudCwgY2FsbGJhY2spXG4gIHtcbiAgICBpZih3aW5kb3cubWFpbkV2ZW50SHViW2h1Yl0gPT0gdW5kZWZpbmVkKSB3aW5kb3cubWFpbkV2ZW50SHViW2h1Yl0gPSBuZXcgVnVlKCk7XG4gICAgcmV0dXJuIHdpbmRvdy5tYWluRXZlbnRIdWJbaHViXS4kb24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgfSxcbiAgb2ZmOiBmdW5jdGlvbihodWIsZXZlbnQsIGNhbGxiYWNrKVxuICB7XG4gICAgaWYod2luZG93Lm1haW5FdmVudEh1YltodWJdID09IHVuZGVmaW5lZCkgd2luZG93Lm1haW5FdmVudEh1YltodWJdID0gbmV3IFZ1ZSgpO1xuICAgIHJldHVybiB3aW5kb3cubWFpbkV2ZW50SHViW2h1Yl0uJG9mZihldmVudCwgY2FsbGJhY2spO1xuICB9XG59O1xuXG5WdWUucHJvdG90eXBlLiRodWJFbWl0ID0gZnVuY3Rpb24oaHViLGV2ZW50LCAuLi5hcmdzKVxue1xuICByZXR1cm4gd2luZG93Lm1haW5FdmVudEh1Yi5lbWl0KGh1YixldmVudCwgYXJncyk7XG59XG5cblZ1ZS5wcm90b3R5cGUuJGh1Yk9uID0gZnVuY3Rpb24oaHViLGV2ZW50LCBjYWxsYmFjaylcbntcbiAgcmV0dXJuIHdpbmRvdy5tYWluRXZlbnRIdWIub24oaHViLGV2ZW50LCBjYWxsYmFjayk7XG59XG5cblZ1ZS5wcm90b3R5cGUuJGh1Yk9mZiA9IGZ1bmN0aW9uKGh1YixldmVudCwgY2FsbGJhY2spXG57XG4gIHJldHVybiB3aW5kb3cubWFpbkV2ZW50SHViLm9mZihodWIsZXZlbnQsIGNhbGxiYWNrKTtcbn1cbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgX3ZtLmNvbXBvbmVudEluc3RhbmNlLFxuICAgIF92bS5fYihcbiAgICAgIHsgdGFnOiBcImNvbXBvbmVudFwiLCBhdHRyczogeyBzbG90OiBfdm0uJHNsb3RzWzBdIH0sIHNsb3Q6IF92bS4kc2xvdHNbMF0gfSxcbiAgICAgIFwiY29tcG9uZW50XCIsXG4gICAgICBfdm0uYXR0cmlidXRlcyxcbiAgICAgIGZhbHNlXG4gICAgKSxcbiAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8Y29tcG9uZW50IDppcz1cImNvbXBvbmVudEluc3RhbmNlXCIgdi1iaW5kPVwiYXR0cmlidXRlc1wiIDpzbG90PVwiJHNsb3RzWzBdXCI+XG4gICAgPHNsb3QvPlxuICA8L2NvbXBvbmVudD5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnbnVsbCcgfSxcbiAgICBwcm9wczogeyB0eXBlOiBTdHJpbmcgfVxuICB9LFxuICBjcmVhdGVkKClcbiAge1xuXG4gIH0sXG4gIGNvbXB1dGVkOlxuICB7XG4gICAgY29tcG9uZW50SW5zdGFuY2UgKClcbiAgICB7XG4gICAgICBpZiAodGhpcy5uYW1lID09ICdudWxsJykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuY2FtZWxpemUodGhpcy5uYW1lLnN1YnN0cmluZyh0aGlzLm5hbWUuaW5kZXhPZignLScpICsgMSkpXG4gICAgICByZXR1cm4gKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiW3JlcXVlc3RdXCIgKi8gYC4vJHtuYW1lfS52dWVgKVxuICAgIH0sXG4gICAgYXR0cmlidXRlcygpXG4gICAge1xuICAgICAgbGV0IGJhc2VPYmogPSBKU09OLnBhcnNlKHRoaXMucHJvcHMpO1xuICAgICAgbGV0IG9iaiA9IHt9XG4gICAgICBmb3IobGV0IGkgaW4gYmFzZU9iailcbiAgICAgIHtcbiAgICAgICAgaWYoaS5zdWJzdHIoMCwxKSA9PSAnOicpXG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgcHJvcCA9IGkuc3Vic3RyKDEpXG4gICAgICAgICAgb2JqW3Byb3BdID0gYmFzZU9ialtpXVxuICAgICAgICB9XG4gICAgICAgIGVsc2Ugb2JqW2ldID0gYmFzZU9ialtpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczpcbiAge1xuICAgIGNhbWVsaXplKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oPzpeXFx3fFtBLVpdfC18XFxiXFx3KS9nLCBmdW5jdGlvbih3b3JkLCBpbmRleClcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTFbMF0ucnVsZXNbMF0udXNlIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUGFnZUxvYWRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMVswXS5ydWxlc1swXS51c2UhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9QYWdlTG9hZGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vUGFnZUxvYWRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjcxYTViOTImXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vUGFnZUxvYWRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1BhZ2VMb2FkZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvVXNlcnMvYW50b2luZS9TaXRlcy9jYWtlcGhwLWFwcC9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCdiNzFhNWI5MicpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCdiNzFhNWI5MicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCdiNzFhNWI5MicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vUGFnZUxvYWRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjcxYTViOTImXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignYjcxYTViOTInLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInZlbmRvci8zeHcvY2FrZXBocC1wYWdlcy9yZXNvdXJjZXMvYXNzZXRzL2NvbXBvbmVudHMvUGFnZUxvYWRlci52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgKG9wdGlvbnMuZnVuY3Rpb25hbCA/IHRoaXMucGFyZW50IDogdGhpcykuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdFxuICAgICAgICApXG4gICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIiwidmFyIG1hcCA9IHtcblx0XCIuL0xpc3QudnVlXCI6IFtcblx0XHQ0NCxcblx0XHQ2MDAsXG5cdFx0NTQ3XG5cdF0sXG5cdFwiLi9MaXN0SXRlbS52dWVcIjogW1xuXHRcdDkwNixcblx0XHQ2MDAsXG5cdFx0NzNcblx0XSxcblx0XCIuL1BhZ2UudnVlXCI6IFtcblx0XHQ1OTIsXG5cdFx0NjAwLFxuXHRcdDY1NFxuXHRdLFxuXHRcIi4vUGFnZUFydGljbGVzSGFuZGxlci52dWVcIjogW1xuXHRcdDMxNCxcblx0XHQ2MDAsXG5cdFx0NjkxXG5cdF0sXG5cdFwiLi9QYWdlSW5wdXQudnVlXCI6IFtcblx0XHQ2MDUsXG5cdFx0MzA1XG5cdF0sXG5cdFwiLi9QYWdlTG9hZGVyLnZ1ZVwiOiBbXG5cdFx0NTA3XG5cdF0sXG5cdFwiLi9QYWdlU2VjdGlvbi52dWVcIjogW1xuXHRcdDYzNCxcblx0XHQ2MDAsXG5cdFx0ODEyXG5cdF0sXG5cdFwiLi9QYWdlU2VjdGlvbkhhbmRsZXIudnVlXCI6IFtcblx0XHQ3ODAsXG5cdFx0NDE3XG5cdF0sXG5cdFwiLi9TZWN0aW9uTW9kYWwudnVlXCI6IFtcblx0XHQ5MjQsXG5cdFx0NjAwLFxuXHRcdDM1NFxuXHRdXG59O1xuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0pO1xuXHR9XG5cblx0dmFyIGlkcyA9IG1hcFtyZXFdLCBpZCA9IGlkc1swXTtcblx0cmV0dXJuIFByb21pc2UuYWxsKGlkcy5zbGljZSgxKS5tYXAoX193ZWJwYWNrX3JlcXVpcmVfXy5lKSkudGhlbigoKSA9PiB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xuXHR9KTtcbn1cbndlYnBhY2tBc3luY0NvbnRleHQua2V5cyA9ICgpID0+IChPYmplY3Qua2V5cyhtYXApKTtcbndlYnBhY2tBc3luY0NvbnRleHQuaWQgPSA3MzA7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tBc3luY0NvbnRleHQ7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZiA9IHt9O1xuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuLy8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSAoY2h1bmtJZCkgPT4ge1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5mKS5yZWR1Y2UoKHByb21pc2VzLCBrZXkpID0+IHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZba2V5XShjaHVua0lkLCBwcm9taXNlcyk7XG5cdFx0cmV0dXJuIHByb21pc2VzO1xuXHR9LCBbXSkpO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhc3luYyBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18udSA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJqcy9wYWdlcy9jb21wb25lbnRzL1wiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5cIiArICh7XCI3M1wiOlwiTGlzdEl0ZW0tdnVlXCIsXCIzMDVcIjpcIlBhZ2VJbnB1dC12dWVcIixcIjM1NFwiOlwiU2VjdGlvbk1vZGFsLXZ1ZVwiLFwiNDE3XCI6XCJQYWdlU2VjdGlvbkhhbmRsZXItdnVlXCIsXCI1NDdcIjpcIkxpc3QtdnVlXCIsXCI2NTRcIjpcIlBhZ2UtdnVlXCIsXCI2OTFcIjpcIlBhZ2VBcnRpY2xlc0hhbmRsZXItdnVlXCIsXCI4MTJcIjpcIlBhZ2VTZWN0aW9uLXZ1ZVwifVtjaHVua0lkXSB8fCBjaHVua0lkKSArIFwiLm1pbi5qc1wiO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm1pbmlDc3NGID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIG5vdCBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRpZiAoY2h1bmtJZCA9PT0gMTc5KSByZXR1cm4gXCJjc3MvcGFnZXMvbWFpbi5taW4uY3NzXCI7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJjc3MvcGFnZXMvY29tcG9uZW50cy9cIiArICh7XCI3M1wiOlwiTGlzdEl0ZW0tdnVlXCIsXCIzMDVcIjpcIlBhZ2VJbnB1dC12dWVcIixcIjM1NFwiOlwiU2VjdGlvbk1vZGFsLXZ1ZVwiLFwiNDE3XCI6XCJQYWdlU2VjdGlvbkhhbmRsZXItdnVlXCIsXCI1NDdcIjpcIkxpc3QtdnVlXCIsXCI2NTRcIjpcIlBhZ2UtdnVlXCIsXCI2OTFcIjpcIlBhZ2VBcnRpY2xlc0hhbmRsZXItdnVlXCIsXCI4MTJcIjpcIlBhZ2VTZWN0aW9uLXZ1ZVwifVtjaHVua0lkXSB8fCBjaHVua0lkKSArIFwiLm1pbi5jc3NcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5oID0gKCkgPT4gKFwiZGZhZmEyMzQ2ZjdiMDI1YWI5ZGNcIikiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwidmFyIGluUHJvZ3Jlc3MgPSB7fTtcbnZhciBkYXRhV2VicGFja1ByZWZpeCA9IFwiY2FrZS13ZWJwYWNrOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXHRcdHNjcmlwdC5zcmMgPSB1cmw7XG5cdH1cblx0aW5Qcm9ncmVzc1t1cmxdID0gW2RvbmVdO1xuXHR2YXIgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCBldmVudCkgPT4ge1xuXHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cblx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR2YXIgZG9uZUZucyA9IGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRkZWxldGUgaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZG9uZUZucyAmJiBkb25lRm5zLmZvckVhY2goKGZuKSA9PiAoZm4oZXZlbnQpKSk7XG5cdFx0aWYocHJldikgcmV0dXJuIHByZXYoZXZlbnQpO1xuXHR9XG5cdDtcblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Nha2VwaHAtYXBwL1wiOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gUHJvbWlzZSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdDE3OTogMFxufTtcblxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaiA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcblx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgPyBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gOiB1bmRlZmluZWQ7XG5cdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7IC8vIDAgbWVhbnMgXCJhbHJlYWR5IGluc3RhbGxlZFwiLlxuXG5cdFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuXHRcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubWVzc2FnZSA9ICdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5uYW1lID0gJ0NodW5rTG9hZEVycm9yJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YVsxXShlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCwgXCJjaHVuay1cIiArIGNodW5rSWQsIGNodW5rSWQpO1xuXHRcdFx0XHR9IGVsc2UgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0XHRcdH1cblx0XHR9XG59O1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBkZWZlcnJlZCBzdGFydHVwXG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRyZXNvbHZlcy5wdXNoKGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSk7XG5cdFx0fVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG5cdH1cblx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0fVxuXHR9XG5cdGlmKHJ1bnRpbWUpIHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG5cdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuXHR9XG5cbn1cblxudmFyIGNodW5rTG9hZGluZ0dsb2JhbCA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtjYWtlX3dlYnBhY2tcIl0gPSBzZWxmW1wid2VicGFja0NodW5rY2FrZV93ZWJwYWNrXCJdIHx8IFtdO1xuY2h1bmtMb2FkaW5nR2xvYmFsLmZvckVhY2god2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCAwKSk7XG5jaHVua0xvYWRpbmdHbG9iYWwucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2guYmluZChjaHVua0xvYWRpbmdHbG9iYWwpKTtcblxuLy8gbm8gZGVmZXJyZWQgc3RhcnR1cCIsIi8vSlNcbnJlcXVpcmUoJ0AvdXRpbHMvd2luZG93LWV2ZW50cy1odWItaG9va3MuanMnKVxuXG5pbXBvcnQgUGFnZUxvYWRlciBmcm9tICdAL2NvbXBvbmVudHMvUGFnZUxvYWRlci52dWUnXG5pbXBvcnQgZHJhZ2dhYmxlIGZyb20gJ3Z1ZWRyYWdnYWJsZSdcblxuVnVlLmNvbXBvbmVudCgnUGFnZUxvYWRlcicsIFBhZ2VMb2FkZXIpXG5WdWUuY29tcG9uZW50KGRyYWdnYWJsZSlcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=